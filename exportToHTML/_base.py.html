<html>
<head>
<title>_base.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_base.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">abc</span>
<span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">BytesIO</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">from </span><span class="s1">textwrap </span><span class="s0">import </span><span class="s1">fill</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">IO</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">Hashable</span><span class="s0">,</span>
    <span class="s1">Iterable</span><span class="s0">,</span>
    <span class="s1">List</span><span class="s0">,</span>
    <span class="s1">Literal</span><span class="s0">,</span>
    <span class="s1">Mapping</span><span class="s0">,</span>
    <span class="s1">Sequence</span><span class="s0">,</span>
    <span class="s1">Union</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
    <span class="s1">overload</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">zipfile</span>

<span class="s0">from </span><span class="s1">pandas._config </span><span class="s0">import </span><span class="s1">config</span>

<span class="s0">from </span><span class="s1">pandas._libs.parsers </span><span class="s0">import </span><span class="s1">STR_NA_VALUES</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DtypeArg</span><span class="s0">,</span>
    <span class="s1">FilePath</span><span class="s0">,</span>
    <span class="s1">IntStrT</span><span class="s0">,</span>
    <span class="s1">ReadBuffer</span><span class="s0">,</span>
    <span class="s1">StorageOptions</span><span class="s0">,</span>
    <span class="s1">WriteExcelBuffer</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.compat._optional </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">get_version</span><span class="s0">,</span>
    <span class="s1">import_optional_dependency</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.errors </span><span class="s0">import </span><span class="s1">EmptyDataError</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Appender</span><span class="s0">,</span>
    <span class="s1">deprecate_nonkeyword_arguments</span><span class="s0">,</span>
    <span class="s1">doc</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.util._exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_bool</span><span class="s0">,</span>
    <span class="s1">is_float</span><span class="s0">,</span>
    <span class="s1">is_integer</span><span class="s0">,</span>
    <span class="s1">is_list_like</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas.core.frame </span><span class="s0">import </span><span class="s1">DataFrame</span>
<span class="s0">from </span><span class="s1">pandas.core.shared_docs </span><span class="s0">import </span><span class="s1">_shared_docs</span>
<span class="s0">from </span><span class="s1">pandas.util.version </span><span class="s0">import </span><span class="s1">Version</span>

<span class="s0">from </span><span class="s1">pandas.io.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">IOHandles</span><span class="s0">,</span>
    <span class="s1">get_handle</span><span class="s0">,</span>
    <span class="s1">stringify_path</span><span class="s0">,</span>
    <span class="s1">validate_header_arg</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.io.excel._util </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">fill_mi_header</span><span class="s0">,</span>
    <span class="s1">get_default_engine</span><span class="s0">,</span>
    <span class="s1">get_writer</span><span class="s0">,</span>
    <span class="s1">maybe_convert_usecols</span><span class="s0">,</span>
    <span class="s1">pop_header_name</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.io.parsers </span><span class="s0">import </span><span class="s1">TextParser</span>

<span class="s1">_read_excel_doc = (</span>
    <span class="s2">&quot;&quot;&quot; 
Read an Excel file into a pandas DataFrame. 
 
Supports `xls`, `xlsx`, `xlsm`, `xlsb`, `odf`, `ods` and `odt` file extensions 
read from a local filesystem or URL. Supports an option to read 
a single sheet or a list of sheets. 
 
Parameters 
---------- 
io : str, bytes, ExcelFile, xlrd.Book, path object, or file-like object 
    Any valid string path is acceptable. The string could be a URL. Valid 
    URL schemes include http, ftp, s3, and file. For file URLs, a host is 
    expected. A local file could be: ``file://localhost/path/to/table.xlsx``. 
 
    If you want to pass in a path object, pandas accepts any ``os.PathLike``. 
 
    By file-like object, we refer to objects with a ``read()`` method, 
    such as a file handle (e.g. via builtin ``open`` function) 
    or ``StringIO``. 
sheet_name : str, int, list, or None, default 0 
    Strings are used for sheet names. Integers are used in zero-indexed 
    sheet positions (chart sheets do not count as a sheet position). 
    Lists of strings/integers are used to request multiple sheets. 
    Specify None to get all worksheets. 
 
    Available cases: 
 
    * Defaults to ``0``: 1st sheet as a `DataFrame` 
    * ``1``: 2nd sheet as a `DataFrame` 
    * ``&quot;Sheet1&quot;``: Load sheet with name &quot;Sheet1&quot; 
    * ``[0, 1, &quot;Sheet5&quot;]``: Load first, second and sheet named &quot;Sheet5&quot; 
      as a dict of `DataFrame` 
    * None: All worksheets. 
 
header : int, list of int, default 0 
    Row (0-indexed) to use for the column labels of the parsed 
    DataFrame. If a list of integers is passed those row positions will 
    be combined into a ``MultiIndex``. Use None if there is no header. 
names : array-like, default None 
    List of column names to use. If file contains no header row, 
    then you should explicitly pass header=None. 
index_col : int, list of int, default None 
    Column (0-indexed) to use as the row labels of the DataFrame. 
    Pass None if there is no such column.  If a list is passed, 
    those columns will be combined into a ``MultiIndex``.  If a 
    subset of data is selected with ``usecols``, index_col 
    is based on the subset. 
usecols : int, str, list-like, or callable default None 
    * If None, then parse all columns. 
    * If str, then indicates comma separated list of Excel column letters 
      and column ranges (e.g. &quot;A:E&quot; or &quot;A,C,E:F&quot;). Ranges are inclusive of 
      both sides. 
    * If list of int, then indicates list of column numbers to be parsed. 
    * If list of string, then indicates list of column names to be parsed. 
    * If callable, then evaluate each column name against it and parse the 
      column if the callable returns ``True``. 
 
    Returns a subset of the columns according to behavior above. 
squeeze : bool, default False 
    If the parsed data only contains one column then return a Series. 
 
    .. deprecated:: 1.4.0 
       Append ``.squeeze(&quot;columns&quot;)`` to the call to ``read_excel`` to squeeze 
       the data. 
dtype : Type name or dict of column -&gt; type, default None 
    Data type for data or columns. E.g. {'a': np.float64, 'b': np.int32} 
    Use `object` to preserve data as stored in Excel and not interpret dtype. 
    If converters are specified, they will be applied INSTEAD 
    of dtype conversion. 
engine : str, default None 
    If io is not a buffer or path, this must be set to identify io. 
    Supported engines: &quot;xlrd&quot;, &quot;openpyxl&quot;, &quot;odf&quot;, &quot;pyxlsb&quot;. 
    Engine compatibility : 
 
    - &quot;xlrd&quot; supports old-style Excel files (.xls). 
    - &quot;openpyxl&quot; supports newer Excel file formats. 
    - &quot;odf&quot; supports OpenDocument file formats (.odf, .ods, .odt). 
    - &quot;pyxlsb&quot; supports Binary Excel files. 
 
    .. versionchanged:: 1.2.0 
        The engine `xlrd &lt;https://xlrd.readthedocs.io/en/latest/&gt;`_ 
        now only supports old-style ``.xls`` files. 
        When ``engine=None``, the following logic will be 
        used to determine the engine: 
 
       - If ``path_or_buffer`` is an OpenDocument format (.odf, .ods, .odt), 
         then `odf &lt;https://pypi.org/project/odfpy/&gt;`_ will be used. 
       - Otherwise if ``path_or_buffer`` is an xls format, 
         ``xlrd`` will be used. 
       - Otherwise if ``path_or_buffer`` is in xlsb format, 
         ``pyxlsb`` will be used. 
 
         .. versionadded:: 1.3.0 
       - Otherwise ``openpyxl`` will be used. 
 
         .. versionchanged:: 1.3.0 
 
converters : dict, default None 
    Dict of functions for converting values in certain columns. Keys can 
    either be integers or column labels, values are functions that take one 
    input argument, the Excel cell content, and return the transformed 
    content. 
true_values : list, default None 
    Values to consider as True. 
false_values : list, default None 
    Values to consider as False. 
skiprows : list-like, int, or callable, optional 
    Line numbers to skip (0-indexed) or number of lines to skip (int) at the 
    start of the file. If callable, the callable function will be evaluated 
    against the row indices, returning True if the row should be skipped and 
    False otherwise. An example of a valid callable argument would be ``lambda 
    x: x in [0, 2]``. 
nrows : int, default None 
    Number of rows to parse. 
na_values : scalar, str, list-like, or dict, default None 
    Additional strings to recognize as NA/NaN. If dict passed, specific 
    per-column NA values. By default the following values are interpreted 
    as NaN: '&quot;&quot;&quot;</span>
    <span class="s1">+ fill(</span><span class="s2">&quot;', '&quot;</span><span class="s1">.join(sorted(STR_NA_VALUES))</span><span class="s0">, </span><span class="s3">70</span><span class="s0">, </span><span class="s1">subsequent_indent=</span><span class="s2">&quot;    &quot;</span><span class="s1">)</span>
    <span class="s1">+ </span><span class="s2">&quot;&quot;&quot;'. 
keep_default_na : bool, default True 
    Whether or not to include the default NaN values when parsing the data. 
    Depending on whether `na_values` is passed in, the behavior is as follows: 
 
    * If `keep_default_na` is True, and `na_values` are specified, `na_values` 
      is appended to the default NaN values used for parsing. 
    * If `keep_default_na` is True, and `na_values` are not specified, only 
      the default NaN values are used for parsing. 
    * If `keep_default_na` is False, and `na_values` are specified, only 
      the NaN values specified `na_values` are used for parsing. 
    * If `keep_default_na` is False, and `na_values` are not specified, no 
      strings will be parsed as NaN. 
 
    Note that if `na_filter` is passed in as False, the `keep_default_na` and 
    `na_values` parameters will be ignored. 
na_filter : bool, default True 
    Detect missing value markers (empty strings and the value of na_values). In 
    data without any NAs, passing na_filter=False can improve the performance 
    of reading a large file. 
verbose : bool, default False 
    Indicate number of NA values placed in non-numeric columns. 
parse_dates : bool, list-like, or dict, default False 
    The behavior is as follows: 
 
    * bool. If True -&gt; try parsing the index. 
    * list of int or names. e.g. If [1, 2, 3] -&gt; try parsing columns 1, 2, 3 
      each as a separate date column. 
    * list of lists. e.g.  If [[1, 3]] -&gt; combine columns 1 and 3 and parse as 
      a single date column. 
    * dict, e.g. {'foo' : [1, 3]} -&gt; parse columns 1, 3 as date and call 
      result 'foo' 
 
    If a column or index contains an unparsable date, the entire column or 
    index will be returned unaltered as an object data type. If you don`t want to 
    parse some cells as date just change their type in Excel to &quot;Text&quot;. 
    For non-standard datetime parsing, use ``pd.to_datetime`` after ``pd.read_excel``. 
 
    Note: A fast-path exists for iso8601-formatted dates. 
date_parser : function, optional 
    Function to use for converting a sequence of string columns to an array of 
    datetime instances. The default uses ``dateutil.parser.parser`` to do the 
    conversion. Pandas will try to call `date_parser` in three different ways, 
    advancing to the next if an exception occurs: 1) Pass one or more arrays 
    (as defined by `parse_dates`) as arguments; 2) concatenate (row-wise) the 
    string values from the columns defined by `parse_dates` into a single array 
    and pass that; and 3) call `date_parser` once for each row using one or 
    more strings (corresponding to the columns defined by `parse_dates`) as 
    arguments. 
thousands : str, default None 
    Thousands separator for parsing string columns to numeric.  Note that 
    this parameter is only necessary for columns stored as TEXT in Excel, 
    any numeric columns will automatically be parsed, regardless of display 
    format. 
decimal : str, default '.' 
    Character to recognize as decimal point for parsing string columns to numeric. 
    Note that this parameter is only necessary for columns stored as TEXT in Excel, 
    any numeric columns will automatically be parsed, regardless of display 
    format.(e.g. use ',' for European data). 
 
    .. versionadded:: 1.4.0 
 
comment : str, default None 
    Comments out remainder of line. Pass a character or characters to this 
    argument to indicate comments in the input file. Any data between the 
    comment string and the end of the current line is ignored. 
skipfooter : int, default 0 
    Rows at the end to skip (0-indexed). 
convert_float : bool, default True 
    Convert integral floats to int (i.e., 1.0 --&gt; 1). If False, all numeric 
    data will be read in as floats: Excel stores all numbers as floats 
    internally. 
 
    .. deprecated:: 1.3.0 
        convert_float will be removed in a future version 
 
mangle_dupe_cols : bool, default True 
    Duplicate columns will be specified as 'X', 'X.1', ...'X.N', rather than 
    'X'...'X'. Passing in False will cause data to be overwritten if there 
    are duplicate names in the columns. 
storage_options : dict, optional 
    Extra options that make sense for a particular storage connection, e.g. 
    host, port, username, password, etc., if using a URL that will 
    be parsed by ``fsspec``, e.g., starting &quot;s3://&quot;, &quot;gcs://&quot;. An error 
    will be raised if providing this argument with a local path or 
    a file-like buffer. See the fsspec and backend storage implementation 
    docs for the set of allowed keys and values. 
 
    .. versionadded:: 1.2.0 
 
Returns 
------- 
DataFrame or dict of DataFrames 
    DataFrame from the passed in Excel file. See notes in sheet_name 
    argument for more information on when a dict of DataFrames is returned. 
 
See Also 
-------- 
DataFrame.to_excel : Write DataFrame to an Excel file. 
DataFrame.to_csv : Write DataFrame to a comma-separated values (csv) file. 
read_csv : Read a comma-separated values (csv) file into DataFrame. 
read_fwf : Read a table of fixed-width formatted lines into DataFrame. 
 
Examples 
-------- 
The file can be read using the file name as string or an open file object: 
 
&gt;&gt;&gt; pd.read_excel('tmp.xlsx', index_col=0)  # doctest: +SKIP 
       Name  Value 
0   string1      1 
1   string2      2 
2  #Comment      3 
 
&gt;&gt;&gt; pd.read_excel(open('tmp.xlsx', 'rb'), 
...               sheet_name='Sheet3')  # doctest: +SKIP 
   Unnamed: 0      Name  Value 
0           0   string1      1 
1           1   string2      2 
2           2  #Comment      3 
 
Index and header can be specified via the `index_col` and `header` arguments 
 
&gt;&gt;&gt; pd.read_excel('tmp.xlsx', index_col=None, header=None)  # doctest: +SKIP 
     0         1      2 
0  NaN      Name  Value 
1  0.0   string1      1 
2  1.0   string2      2 
3  2.0  #Comment      3 
 
Column types are inferred but can be explicitly specified 
 
&gt;&gt;&gt; pd.read_excel('tmp.xlsx', index_col=0, 
...               dtype={'Name': str, 'Value': float})  # doctest: +SKIP 
       Name  Value 
0   string1    1.0 
1   string2    2.0 
2  #Comment    3.0 
 
True, False, and NA values, and thousands separators have defaults, 
but can be explicitly specified, too. Supply the values you would like 
as strings or lists of strings! 
 
&gt;&gt;&gt; pd.read_excel('tmp.xlsx', index_col=0, 
...               na_values=['string1', 'string2'])  # doctest: +SKIP 
       Name  Value 
0       NaN      1 
1       NaN      2 
2  #Comment      3 
 
Comment lines in the excel input file can be skipped using the `comment` kwarg 
 
&gt;&gt;&gt; pd.read_excel('tmp.xlsx', index_col=0, comment='#')  # doctest: +SKIP 
      Name  Value 
0  string1    1.0 
1  string2    2.0 
2     None    NaN 
&quot;&quot;&quot;</span>
<span class="s1">)</span>


<span class="s1">@overload</span>
<span class="s0">def </span><span class="s1">read_excel(</span>
    <span class="s1">io</span><span class="s0">,</span>
    <span class="s4"># sheet name is str or int -&gt; DataFrame</span>
    <span class="s1">sheet_name: str | int</span><span class="s0">,</span>
    <span class="s1">header: int | Sequence[int] | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">names=...</span><span class="s0">,</span>
    <span class="s1">index_col: int | Sequence[int] | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">usecols=...</span><span class="s0">,</span>
    <span class="s1">squeeze: bool | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">dtype: DtypeArg | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">engine: Literal[</span><span class="s2">&quot;xlrd&quot;</span><span class="s0">, </span><span class="s2">&quot;openpyxl&quot;</span><span class="s0">, </span><span class="s2">&quot;odf&quot;</span><span class="s0">, </span><span class="s2">&quot;pyxlsb&quot;</span><span class="s1">] | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">converters=...</span><span class="s0">,</span>
    <span class="s1">true_values: Iterable[Hashable] | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">false_values: Iterable[Hashable] | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">skiprows: Sequence[int] | int | Callable[[int]</span><span class="s0">, </span><span class="s1">object] | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">nrows: int | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">na_values=...</span><span class="s0">,</span>
    <span class="s1">keep_default_na: bool = ...</span><span class="s0">,</span>
    <span class="s1">na_filter: bool = ...</span><span class="s0">,</span>
    <span class="s1">verbose: bool = ...</span><span class="s0">,</span>
    <span class="s1">parse_dates=...</span><span class="s0">,</span>
    <span class="s1">date_parser=...</span><span class="s0">,</span>
    <span class="s1">thousands: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">decimal: str = ...</span><span class="s0">,</span>
    <span class="s1">comment: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">skipfooter: int = ...</span><span class="s0">,</span>
    <span class="s1">convert_float: bool | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">mangle_dupe_cols: bool = ...</span><span class="s0">,</span>
    <span class="s1">storage_options: StorageOptions = ...</span><span class="s0">,</span>
<span class="s1">) -&gt; DataFrame:</span>
    <span class="s1">...</span>


<span class="s1">@overload</span>
<span class="s0">def </span><span class="s1">read_excel(</span>
    <span class="s1">io</span><span class="s0">,</span>
    <span class="s4"># sheet name is list or None -&gt; dict[IntStrT, DataFrame]</span>
    <span class="s1">sheet_name: list[IntStrT] | </span><span class="s0">None,</span>
    <span class="s1">header: int | Sequence[int] | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">names=...</span><span class="s0">,</span>
    <span class="s1">index_col: int | Sequence[int] | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">usecols=...</span><span class="s0">,</span>
    <span class="s1">squeeze: bool | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">dtype: DtypeArg | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">engine: Literal[</span><span class="s2">&quot;xlrd&quot;</span><span class="s0">, </span><span class="s2">&quot;openpyxl&quot;</span><span class="s0">, </span><span class="s2">&quot;odf&quot;</span><span class="s0">, </span><span class="s2">&quot;pyxlsb&quot;</span><span class="s1">] | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">converters=...</span><span class="s0">,</span>
    <span class="s1">true_values: Iterable[Hashable] | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">false_values: Iterable[Hashable] | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">skiprows: Sequence[int] | int | Callable[[int]</span><span class="s0">, </span><span class="s1">object] | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">nrows: int | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">na_values=...</span><span class="s0">,</span>
    <span class="s1">keep_default_na: bool = ...</span><span class="s0">,</span>
    <span class="s1">na_filter: bool = ...</span><span class="s0">,</span>
    <span class="s1">verbose: bool = ...</span><span class="s0">,</span>
    <span class="s1">parse_dates=...</span><span class="s0">,</span>
    <span class="s1">date_parser=...</span><span class="s0">,</span>
    <span class="s1">thousands: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">decimal: str = ...</span><span class="s0">,</span>
    <span class="s1">comment: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">skipfooter: int = ...</span><span class="s0">,</span>
    <span class="s1">convert_float: bool | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">mangle_dupe_cols: bool = ...</span><span class="s0">,</span>
    <span class="s1">storage_options: StorageOptions = ...</span><span class="s0">,</span>
<span class="s1">) -&gt; dict[IntStrT</span><span class="s0">, </span><span class="s1">DataFrame]:</span>
    <span class="s1">...</span>


<span class="s1">@deprecate_nonkeyword_arguments(allowed_args=[</span><span class="s2">&quot;io&quot;</span><span class="s0">, </span><span class="s2">&quot;sheet_name&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">version=</span><span class="s2">&quot;2.0&quot;</span><span class="s1">)</span>
<span class="s1">@Appender(_read_excel_doc)</span>
<span class="s0">def </span><span class="s1">read_excel(</span>
    <span class="s1">io</span><span class="s0">,</span>
    <span class="s1">sheet_name: str | int | list[IntStrT] | </span><span class="s0">None </span><span class="s1">= </span><span class="s3">0</span><span class="s0">,</span>
    <span class="s1">header: int | Sequence[int] | </span><span class="s0">None </span><span class="s1">= </span><span class="s3">0</span><span class="s0">,</span>
    <span class="s1">names=</span><span class="s0">None,</span>
    <span class="s1">index_col: int | Sequence[int] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">usecols=</span><span class="s0">None,</span>
    <span class="s1">squeeze: bool | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">dtype: DtypeArg | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">engine: Literal[</span><span class="s2">&quot;xlrd&quot;</span><span class="s0">, </span><span class="s2">&quot;openpyxl&quot;</span><span class="s0">, </span><span class="s2">&quot;odf&quot;</span><span class="s0">, </span><span class="s2">&quot;pyxlsb&quot;</span><span class="s1">] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">converters=</span><span class="s0">None,</span>
    <span class="s1">true_values: Iterable[Hashable] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">false_values: Iterable[Hashable] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">skiprows: Sequence[int] | int | Callable[[int]</span><span class="s0">, </span><span class="s1">object] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">nrows: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">na_values=</span><span class="s0">None,</span>
    <span class="s1">keep_default_na: bool = </span><span class="s0">True,</span>
    <span class="s1">na_filter: bool = </span><span class="s0">True,</span>
    <span class="s1">verbose: bool = </span><span class="s0">False,</span>
    <span class="s1">parse_dates=</span><span class="s0">False,</span>
    <span class="s1">date_parser=</span><span class="s0">None,</span>
    <span class="s1">thousands: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">decimal: str = </span><span class="s2">&quot;.&quot;</span><span class="s0">,</span>
    <span class="s1">comment: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">skipfooter: int = </span><span class="s3">0</span><span class="s0">,</span>
    <span class="s1">convert_float: bool | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">mangle_dupe_cols: bool = </span><span class="s0">True,</span>
    <span class="s1">storage_options: StorageOptions = </span><span class="s0">None,</span>
<span class="s1">) -&gt; DataFrame | dict[IntStrT</span><span class="s0">, </span><span class="s1">DataFrame]:</span>

    <span class="s1">should_close = </span><span class="s0">False</span>
    <span class="s0">if not </span><span class="s1">isinstance(io</span><span class="s0">, </span><span class="s1">ExcelFile):</span>
        <span class="s1">should_close = </span><span class="s0">True</span>
        <span class="s1">io = ExcelFile(io</span><span class="s0">, </span><span class="s1">storage_options=storage_options</span><span class="s0">, </span><span class="s1">engine=engine)</span>
    <span class="s0">elif </span><span class="s1">engine </span><span class="s0">and </span><span class="s1">engine != io.engine:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s2">&quot;Engine should not be specified when passing &quot;</span>
            <span class="s2">&quot;an ExcelFile - ExcelFile already has the engine set&quot;</span>
        <span class="s1">)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">data = io.parse(</span>
            <span class="s1">sheet_name=sheet_name</span><span class="s0">,</span>
            <span class="s1">header=header</span><span class="s0">,</span>
            <span class="s1">names=names</span><span class="s0">,</span>
            <span class="s1">index_col=index_col</span><span class="s0">,</span>
            <span class="s1">usecols=usecols</span><span class="s0">,</span>
            <span class="s1">squeeze=squeeze</span><span class="s0">,</span>
            <span class="s1">dtype=dtype</span><span class="s0">,</span>
            <span class="s1">converters=converters</span><span class="s0">,</span>
            <span class="s1">true_values=true_values</span><span class="s0">,</span>
            <span class="s1">false_values=false_values</span><span class="s0">,</span>
            <span class="s1">skiprows=skiprows</span><span class="s0">,</span>
            <span class="s1">nrows=nrows</span><span class="s0">,</span>
            <span class="s1">na_values=na_values</span><span class="s0">,</span>
            <span class="s1">keep_default_na=keep_default_na</span><span class="s0">,</span>
            <span class="s1">na_filter=na_filter</span><span class="s0">,</span>
            <span class="s1">verbose=verbose</span><span class="s0">,</span>
            <span class="s1">parse_dates=parse_dates</span><span class="s0">,</span>
            <span class="s1">date_parser=date_parser</span><span class="s0">,</span>
            <span class="s1">thousands=thousands</span><span class="s0">,</span>
            <span class="s1">decimal=decimal</span><span class="s0">,</span>
            <span class="s1">comment=comment</span><span class="s0">,</span>
            <span class="s1">skipfooter=skipfooter</span><span class="s0">,</span>
            <span class="s1">convert_float=convert_float</span><span class="s0">,</span>
            <span class="s1">mangle_dupe_cols=mangle_dupe_cols</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s4"># make sure to close opened file handles</span>
        <span class="s0">if </span><span class="s1">should_close:</span>
            <span class="s1">io.close()</span>
    <span class="s0">return </span><span class="s1">data</span>


<span class="s0">class </span><span class="s1">BaseExcelReader(metaclass=abc.ABCMeta):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">filepath_or_buffer</span><span class="s0">, </span><span class="s1">storage_options: StorageOptions = </span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4"># First argument can also be bytes, so create a buffer</span>
        <span class="s0">if </span><span class="s1">isinstance(filepath_or_buffer</span><span class="s0">, </span><span class="s1">bytes):</span>
            <span class="s1">filepath_or_buffer = BytesIO(filepath_or_buffer)</span>

        <span class="s1">self.handles = IOHandles(</span>
            <span class="s1">handle=filepath_or_buffer</span><span class="s0">, </span><span class="s1">compression={</span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s0">None</span><span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">isinstance(filepath_or_buffer</span><span class="s0">, </span><span class="s1">(ExcelFile</span><span class="s0">, </span><span class="s1">self._workbook_class)):</span>
            <span class="s1">self.handles = get_handle(</span>
                <span class="s1">filepath_or_buffer</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s0">, </span><span class="s1">storage_options=storage_options</span><span class="s0">, </span><span class="s1">is_text=</span><span class="s0">False</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">isinstance(self.handles.handle</span><span class="s0">, </span><span class="s1">self._workbook_class):</span>
            <span class="s1">self.book = self.handles.handle</span>
        <span class="s0">elif </span><span class="s1">hasattr(self.handles.handle</span><span class="s0">, </span><span class="s2">&quot;read&quot;</span><span class="s1">):</span>
            <span class="s4"># N.B. xlrd.Book has a read attribute too</span>
            <span class="s1">self.handles.handle.seek(</span><span class="s3">0</span><span class="s1">)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">self.book = self.load_workbook(self.handles.handle)</span>
            <span class="s0">except </span><span class="s1">Exception:</span>
                <span class="s1">self.close()</span>
                <span class="s0">raise</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Must explicitly set engine if not passing in buffer or path for io.&quot;</span>
            <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">_workbook_class(self):</span>
        <span class="s0">pass</span>

    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">load_workbook(self</span><span class="s0">, </span><span class="s1">filepath_or_buffer):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">close(self):</span>
        <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s2">&quot;book&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">hasattr(self.book</span><span class="s0">, </span><span class="s2">&quot;close&quot;</span><span class="s1">):</span>
            <span class="s4"># pyxlsb: opens a TemporaryFile</span>
            <span class="s4"># openpyxl: https://stackoverflow.com/questions/31416842/</span>
            <span class="s4">#     openpyxl-does-not-close-excel-workbook-in-read-only-mode</span>
            <span class="s1">self.book.close()</span>
        <span class="s1">self.handles.close()</span>

    <span class="s1">@property</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">sheet_names(self) -&gt; list[str]:</span>
        <span class="s0">pass</span>

    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_sheet_by_name(self</span><span class="s0">, </span><span class="s1">name: str):</span>
        <span class="s0">pass</span>

    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_sheet_by_index(self</span><span class="s0">, </span><span class="s1">index: int):</span>
        <span class="s0">pass</span>

    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">get_sheet_data(self</span><span class="s0">, </span><span class="s1">sheet</span><span class="s0">, </span><span class="s1">convert_float: bool):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">raise_if_bad_sheet_by_index(self</span><span class="s0">, </span><span class="s1">index: int) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">n_sheets = len(self.sheet_names)</span>
        <span class="s0">if </span><span class="s1">index &gt;= n_sheets:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">f&quot;Worksheet index </span><span class="s0">{</span><span class="s1">index</span><span class="s0">} </span><span class="s2">is invalid, </span><span class="s0">{</span><span class="s1">n_sheets</span><span class="s0">} </span><span class="s2">worksheets found&quot;</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">raise_if_bad_sheet_by_name(self</span><span class="s0">, </span><span class="s1">name: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">self.sheet_names:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;Worksheet named '</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s2">' not found&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">parse(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">sheet_name: str | int | list[int] | list[str] | </span><span class="s0">None </span><span class="s1">= </span><span class="s3">0</span><span class="s0">,</span>
        <span class="s1">header: int | Sequence[int] | </span><span class="s0">None </span><span class="s1">= </span><span class="s3">0</span><span class="s0">,</span>
        <span class="s1">names=</span><span class="s0">None,</span>
        <span class="s1">index_col: int | Sequence[int] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">usecols=</span><span class="s0">None,</span>
        <span class="s1">squeeze: bool | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">dtype: DtypeArg | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">true_values: Iterable[Hashable] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">false_values: Iterable[Hashable] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">skiprows: Sequence[int] | int | Callable[[int]</span><span class="s0">, </span><span class="s1">object] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">nrows: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">na_values=</span><span class="s0">None,</span>
        <span class="s1">verbose: bool = </span><span class="s0">False,</span>
        <span class="s1">parse_dates=</span><span class="s0">False,</span>
        <span class="s1">date_parser=</span><span class="s0">None,</span>
        <span class="s1">thousands: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">decimal: str = </span><span class="s2">&quot;.&quot;</span><span class="s0">,</span>
        <span class="s1">comment: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">skipfooter: int = </span><span class="s3">0</span><span class="s0">,</span>
        <span class="s1">convert_float: bool | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">mangle_dupe_cols: bool = </span><span class="s0">True,</span>
        <span class="s1">**kwds</span><span class="s0">,</span>
    <span class="s1">):</span>

        <span class="s0">if </span><span class="s1">convert_float </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">convert_float = </span><span class="s0">True</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;convert_float is deprecated and will be removed in a future version.&quot;</span><span class="s0">,</span>
                <span class="s1">FutureWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s1">validate_header_arg(header)</span>

        <span class="s1">ret_dict = </span><span class="s0">False</span>

        <span class="s4"># Keep sheetname to maintain backwards compatibility.</span>
        <span class="s1">sheets: list[int] | list[str]</span>
        <span class="s0">if </span><span class="s1">isinstance(sheet_name</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s1">sheets = sheet_name</span>
            <span class="s1">ret_dict = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">sheet_name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">sheets = self.sheet_names</span>
            <span class="s1">ret_dict = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">isinstance(sheet_name</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">sheets = [sheet_name]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">sheets = [sheet_name]</span>

        <span class="s4"># handle same-type duplicates.</span>
        <span class="s1">sheets = cast(Union[List[int]</span><span class="s0">, </span><span class="s1">List[str]]</span><span class="s0">, </span><span class="s1">list(dict.fromkeys(sheets).keys()))</span>

        <span class="s1">output = {}</span>

        <span class="s0">for </span><span class="s1">asheetname </span><span class="s0">in </span><span class="s1">sheets:</span>
            <span class="s0">if </span><span class="s1">verbose:</span>
                <span class="s1">print(</span><span class="s2">f&quot;Reading sheet </span><span class="s0">{</span><span class="s1">asheetname</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">isinstance(asheetname</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s1">sheet = self.get_sheet_by_name(asheetname)</span>
            <span class="s0">else</span><span class="s1">:  </span><span class="s4"># assume an integer if not a string</span>
                <span class="s1">sheet = self.get_sheet_by_index(asheetname)</span>

            <span class="s1">data = self.get_sheet_data(sheet</span><span class="s0">, </span><span class="s1">convert_float)</span>
            <span class="s0">if </span><span class="s1">hasattr(sheet</span><span class="s0">, </span><span class="s2">&quot;close&quot;</span><span class="s1">):</span>
                <span class="s4"># pyxlsb opens two TemporaryFiles</span>
                <span class="s1">sheet.close()</span>
            <span class="s1">usecols = maybe_convert_usecols(usecols)</span>

            <span class="s0">if not </span><span class="s1">data:</span>
                <span class="s1">output[asheetname] = DataFrame()</span>
                <span class="s0">continue</span>

            <span class="s1">is_list_header = </span><span class="s0">False</span>
            <span class="s1">is_len_one_list_header = </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">is_list_like(header):</span>
                <span class="s0">assert </span><span class="s1">isinstance(header</span><span class="s0">, </span><span class="s1">Sequence)</span>
                <span class="s1">is_list_header = </span><span class="s0">True</span>
                <span class="s0">if </span><span class="s1">len(header) == </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">is_len_one_list_header = </span><span class="s0">True</span>

            <span class="s0">if </span><span class="s1">is_len_one_list_header:</span>
                <span class="s1">header = cast(Sequence[int]</span><span class="s0">, </span><span class="s1">header)[</span><span class="s3">0</span><span class="s1">]</span>

            <span class="s4"># forward fill and pull out names for MultiIndex column</span>
            <span class="s1">header_names = </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">header </span><span class="s0">is not None and </span><span class="s1">is_list_like(header):</span>
                <span class="s0">assert </span><span class="s1">isinstance(header</span><span class="s0">, </span><span class="s1">Sequence)</span>

                <span class="s1">header_names = []</span>
                <span class="s1">control_row = [</span><span class="s0">True</span><span class="s1">] * len(data[</span><span class="s3">0</span><span class="s1">])</span>

                <span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">header:</span>
                    <span class="s0">if </span><span class="s1">is_integer(skiprows):</span>
                        <span class="s0">assert </span><span class="s1">isinstance(skiprows</span><span class="s0">, </span><span class="s1">int)</span>
                        <span class="s1">row += skiprows</span>

                    <span class="s1">data[row]</span><span class="s0">, </span><span class="s1">control_row = fill_mi_header(data[row]</span><span class="s0">, </span><span class="s1">control_row)</span>

                    <span class="s0">if </span><span class="s1">index_col </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s1">header_name</span><span class="s0">, </span><span class="s1">_ = pop_header_name(data[row]</span><span class="s0">, </span><span class="s1">index_col)</span>
                        <span class="s1">header_names.append(header_name)</span>

            <span class="s4"># If there is a MultiIndex header and an index then there is also</span>
            <span class="s4"># a row containing just the index name(s)</span>
            <span class="s1">has_index_names = (</span>
                <span class="s1">is_list_header </span><span class="s0">and not </span><span class="s1">is_len_one_list_header </span><span class="s0">and </span><span class="s1">index_col </span><span class="s0">is not None</span>
            <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">is_list_like(index_col):</span>
                <span class="s4"># Forward fill values for MultiIndex index.</span>
                <span class="s0">if </span><span class="s1">header </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">offset = </span><span class="s3">0</span>
                <span class="s0">elif </span><span class="s1">isinstance(header</span><span class="s0">, </span><span class="s1">int):</span>
                    <span class="s1">offset = </span><span class="s3">1 </span><span class="s1">+ header</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">offset = </span><span class="s3">1 </span><span class="s1">+ max(header)</span>

                <span class="s4"># GH34673: if MultiIndex names present and not defined in the header,</span>
                <span class="s4"># offset needs to be incremented so that forward filling starts</span>
                <span class="s4"># from the first MI value instead of the name</span>
                <span class="s0">if </span><span class="s1">has_index_names:</span>
                    <span class="s1">offset += </span><span class="s3">1</span>

                <span class="s4"># Check if we have an empty dataset</span>
                <span class="s4"># before trying to collect data.</span>
                <span class="s0">if </span><span class="s1">offset &lt; len(data):</span>
                    <span class="s0">assert </span><span class="s1">isinstance(index_col</span><span class="s0">, </span><span class="s1">Sequence)</span>

                    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">index_col:</span>
                        <span class="s1">last = data[offset][col]</span>

                        <span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">range(offset + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">len(data)):</span>
                            <span class="s0">if </span><span class="s1">data[row][col] == </span><span class="s2">&quot;&quot; </span><span class="s0">or </span><span class="s1">data[row][col] </span><span class="s0">is None</span><span class="s1">:</span>
                                <span class="s1">data[row][col] = last</span>
                            <span class="s0">else</span><span class="s1">:</span>
                                <span class="s1">last = data[row][col]</span>

            <span class="s4"># GH 12292 : error when read one empty column from excel file</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">parser = TextParser(</span>
                    <span class="s1">data</span><span class="s0">,</span>
                    <span class="s1">names=names</span><span class="s0">,</span>
                    <span class="s1">header=header</span><span class="s0">,</span>
                    <span class="s1">index_col=index_col</span><span class="s0">,</span>
                    <span class="s1">has_index_names=has_index_names</span><span class="s0">,</span>
                    <span class="s1">squeeze=squeeze</span><span class="s0">,</span>
                    <span class="s1">dtype=dtype</span><span class="s0">,</span>
                    <span class="s1">true_values=true_values</span><span class="s0">,</span>
                    <span class="s1">false_values=false_values</span><span class="s0">,</span>
                    <span class="s1">skiprows=skiprows</span><span class="s0">,</span>
                    <span class="s1">nrows=nrows</span><span class="s0">,</span>
                    <span class="s1">na_values=na_values</span><span class="s0">,</span>
                    <span class="s1">skip_blank_lines=</span><span class="s0">False,  </span><span class="s4"># GH 39808</span>
                    <span class="s1">parse_dates=parse_dates</span><span class="s0">,</span>
                    <span class="s1">date_parser=date_parser</span><span class="s0">,</span>
                    <span class="s1">thousands=thousands</span><span class="s0">,</span>
                    <span class="s1">decimal=decimal</span><span class="s0">,</span>
                    <span class="s1">comment=comment</span><span class="s0">,</span>
                    <span class="s1">skipfooter=skipfooter</span><span class="s0">,</span>
                    <span class="s1">usecols=usecols</span><span class="s0">,</span>
                    <span class="s1">mangle_dupe_cols=mangle_dupe_cols</span><span class="s0">,</span>
                    <span class="s1">**kwds</span><span class="s0">,</span>
                <span class="s1">)</span>

                <span class="s1">output[asheetname] = parser.read(nrows=nrows)</span>

                <span class="s0">if not </span><span class="s1">squeeze </span><span class="s0">or </span><span class="s1">isinstance(output[asheetname]</span><span class="s0">, </span><span class="s1">DataFrame):</span>
                    <span class="s0">if </span><span class="s1">header_names:</span>
                        <span class="s1">output[asheetname].columns = output[</span>
                            <span class="s1">asheetname</span>
                        <span class="s1">].columns.set_names(header_names)</span>

            <span class="s0">except </span><span class="s1">EmptyDataError:</span>
                <span class="s4"># No Data, return an empty DataFrame</span>
                <span class="s1">output[asheetname] = DataFrame()</span>

        <span class="s0">if </span><span class="s1">ret_dict:</span>
            <span class="s0">return </span><span class="s1">output</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">output[asheetname]</span>


<span class="s0">class </span><span class="s1">ExcelWriter(metaclass=abc.ABCMeta):</span>
    <span class="s5">&quot;&quot;&quot; 
    Class for writing DataFrame objects into excel sheets. 
 
    Default is to use : 
    * xlwt for xls 
    * xlsxwriter for xlsx if xlsxwriter is installed otherwise openpyxl 
    * odf for ods. 
    See DataFrame.to_excel for typical usage. 
 
    The writer should be used as a context manager. Otherwise, call `close()` to save 
    and close any opened file handles. 
 
    Parameters 
    ---------- 
    path : str or typing.BinaryIO 
        Path to xls or xlsx or ods file. 
    engine : str (optional) 
        Engine to use for writing. If None, defaults to 
        ``io.excel.&lt;extension&gt;.writer``.  NOTE: can only be passed as a keyword 
        argument. 
 
        .. deprecated:: 1.2.0 
 
            As the `xlwt &lt;https://pypi.org/project/xlwt/&gt;`__ package is no longer 
            maintained, the ``xlwt`` engine will be removed in a future 
            version of pandas. 
 
    date_format : str, default None 
        Format string for dates written into Excel files (e.g. 'YYYY-MM-DD'). 
    datetime_format : str, default None 
        Format string for datetime objects written into Excel files. 
        (e.g. 'YYYY-MM-DD HH:MM:SS'). 
    mode : {'w', 'a'}, default 'w' 
        File mode to use (write or append). Append does not work with fsspec URLs. 
    storage_options : dict, optional 
        Extra options that make sense for a particular storage connection, e.g. 
        host, port, username, password, etc., if using a URL that will 
        be parsed by ``fsspec``, e.g., starting &quot;s3://&quot;, &quot;gcs://&quot;. 
 
        .. versionadded:: 1.2.0 
 
    if_sheet_exists : {'error', 'new', 'replace', 'overlay'}, default 'error' 
        How to behave when trying to write to a sheet that already 
        exists (append mode only). 
 
        * error: raise a ValueError. 
        * new: Create a new sheet, with a name determined by the engine. 
        * replace: Delete the contents of the sheet before writing to it. 
        * overlay: Write contents to the existing sheet without removing the old 
          contents. 
 
        .. versionadded:: 1.3.0 
 
        .. versionchanged:: 1.4.0 
 
           Added ``overlay`` option 
 
    engine_kwargs : dict, optional 
        Keyword arguments to be passed into the engine. These will be passed to 
        the following functions of the respective engines: 
 
        * xlsxwriter: ``xlsxwriter.Workbook(file, **engine_kwargs)`` 
        * openpyxl (write mode): ``openpyxl.Workbook(**engine_kwargs)`` 
        * openpyxl (append mode): ``openpyxl.load_workbook(file, **engine_kwargs)`` 
        * odswriter: ``odf.opendocument.OpenDocumentSpreadsheet(**engine_kwargs)`` 
 
        .. versionadded:: 1.3.0 
    **kwargs : dict, optional 
        Keyword arguments to be passed into the engine. 
 
        .. deprecated:: 1.3.0 
 
            Use engine_kwargs instead. 
 
    Attributes 
    ---------- 
    None 
 
    Methods 
    ------- 
    None 
 
    Notes 
    ----- 
    None of the methods and properties are considered public. 
 
    For compatibility with CSV writers, ExcelWriter serializes lists 
    and dicts to strings before writing. 
 
    Examples 
    -------- 
    Default usage: 
 
    &gt;&gt;&gt; df = pd.DataFrame([[&quot;ABC&quot;, &quot;XYZ&quot;]], columns=[&quot;Foo&quot;, &quot;Bar&quot;])  # doctest: +SKIP 
    &gt;&gt;&gt; with pd.ExcelWriter(&quot;path_to_file.xlsx&quot;) as writer: 
    ...     df.to_excel(writer)  # doctest: +SKIP 
 
    To write to separate sheets in a single file: 
 
    &gt;&gt;&gt; df1 = pd.DataFrame([[&quot;AAA&quot;, &quot;BBB&quot;]], columns=[&quot;Spam&quot;, &quot;Egg&quot;])  # doctest: +SKIP 
    &gt;&gt;&gt; df2 = pd.DataFrame([[&quot;ABC&quot;, &quot;XYZ&quot;]], columns=[&quot;Foo&quot;, &quot;Bar&quot;])  # doctest: +SKIP 
    &gt;&gt;&gt; with pd.ExcelWriter(&quot;path_to_file.xlsx&quot;) as writer: 
    ...     df1.to_excel(writer, sheet_name=&quot;Sheet1&quot;)  # doctest: +SKIP 
    ...     df2.to_excel(writer, sheet_name=&quot;Sheet2&quot;)  # doctest: +SKIP 
 
    You can set the date format or datetime format: 
 
    &gt;&gt;&gt; from datetime import date, datetime  # doctest: +SKIP 
    &gt;&gt;&gt; df = pd.DataFrame( 
    ...     [ 
    ...         [date(2014, 1, 31), date(1999, 9, 24)], 
    ...         [datetime(1998, 5, 26, 23, 33, 4), datetime(2014, 2, 28, 13, 5, 13)], 
    ...     ], 
    ...     index=[&quot;Date&quot;, &quot;Datetime&quot;], 
    ...     columns=[&quot;X&quot;, &quot;Y&quot;], 
    ... )  # doctest: +SKIP 
    &gt;&gt;&gt; with pd.ExcelWriter( 
    ...     &quot;path_to_file.xlsx&quot;, 
    ...     date_format=&quot;YYYY-MM-DD&quot;, 
    ...     datetime_format=&quot;YYYY-MM-DD HH:MM:SS&quot; 
    ... ) as writer: 
    ...     df.to_excel(writer)  # doctest: +SKIP 
 
    You can also append to an existing Excel file: 
 
    &gt;&gt;&gt; with pd.ExcelWriter(&quot;path_to_file.xlsx&quot;, mode=&quot;a&quot;, engine=&quot;openpyxl&quot;) as writer: 
    ...     df.to_excel(writer, sheet_name=&quot;Sheet3&quot;)  # doctest: +SKIP 
 
    Here, the `if_sheet_exists` parameter can be set to replace a sheet if it 
    already exists: 
 
    &gt;&gt;&gt; with ExcelWriter( 
    ...     &quot;path_to_file.xlsx&quot;, 
    ...     mode=&quot;a&quot;, 
    ...     engine=&quot;openpyxl&quot;, 
    ...     if_sheet_exists=&quot;replace&quot;, 
    ... ) as writer: 
    ...     df.to_excel(writer, sheet_name=&quot;Sheet1&quot;)  # doctest: +SKIP 
 
    You can also write multiple DataFrames to a single sheet. Note that the 
    ``if_sheet_exists`` parameter needs to be set to ``overlay``: 
 
    &gt;&gt;&gt; with ExcelWriter(&quot;path_to_file.xlsx&quot;, 
    ...     mode=&quot;a&quot;, 
    ...     engine=&quot;openpyxl&quot;, 
    ...     if_sheet_exists=&quot;overlay&quot;, 
    ... ) as writer: 
    ...     df1.to_excel(writer, sheet_name=&quot;Sheet1&quot;) 
    ...     df2.to_excel(writer, sheet_name=&quot;Sheet1&quot;, startcol=3)  # doctest: +SKIP 
 
    You can store Excel file in RAM: 
 
    &gt;&gt;&gt; import io 
    &gt;&gt;&gt; df = pd.DataFrame([[&quot;ABC&quot;, &quot;XYZ&quot;]], columns=[&quot;Foo&quot;, &quot;Bar&quot;]) 
    &gt;&gt;&gt; buffer = io.BytesIO() 
    &gt;&gt;&gt; with pd.ExcelWriter(buffer) as writer: 
    ...     df.to_excel(writer) 
 
    You can pack Excel file into zip archive: 
 
    &gt;&gt;&gt; import zipfile  # doctest: +SKIP 
    &gt;&gt;&gt; df = pd.DataFrame([[&quot;ABC&quot;, &quot;XYZ&quot;]], columns=[&quot;Foo&quot;, &quot;Bar&quot;])  # doctest: +SKIP 
    &gt;&gt;&gt; with zipfile.ZipFile(&quot;path_to_file.zip&quot;, &quot;w&quot;) as zf: 
    ...     with zf.open(&quot;filename.xlsx&quot;, &quot;w&quot;) as buffer: 
    ...         with pd.ExcelWriter(buffer) as writer: 
    ...             df.to_excel(writer)  # doctest: +SKIP 
 
    You can specify additional arguments to the underlying engine: 
 
    &gt;&gt;&gt; with pd.ExcelWriter( 
    ...     &quot;path_to_file.xlsx&quot;, 
    ...     engine=&quot;xlsxwriter&quot;, 
    ...     engine_kwargs={&quot;options&quot;: {&quot;nan_inf_to_errors&quot;: True}} 
    ... ) as writer: 
    ...     df.to_excel(writer)  # doctest: +SKIP 
 
    In append mode, ``engine_kwargs`` are passed through to 
    openpyxl's ``load_workbook``: 
 
    &gt;&gt;&gt; with pd.ExcelWriter( 
    ...     &quot;path_to_file.xlsx&quot;, 
    ...     engine=&quot;openpyxl&quot;, 
    ...     mode=&quot;a&quot;, 
    ...     engine_kwargs={&quot;keep_vba&quot;: True} 
    ... ) as writer: 
    ...     df.to_excel(writer, sheet_name=&quot;Sheet2&quot;)  # doctest: +SKIP 
    &quot;&quot;&quot;</span>

    <span class="s4"># Defining an ExcelWriter implementation (see abstract methods for more...)</span>

    <span class="s4"># - Mandatory</span>
    <span class="s4">#   - ``write_cells(self, cells, sheet_name=None, startrow=0, startcol=0)``</span>
    <span class="s4">#     --&gt; called to write additional DataFrames to disk</span>
    <span class="s4">#   - ``supported_extensions`` (tuple of supported extensions), used to</span>
    <span class="s4">#      check that engine supports the given extension.</span>
    <span class="s4">#   - ``engine`` - string that gives the engine name. Necessary to</span>
    <span class="s4">#     instantiate class directly and bypass ``ExcelWriterMeta`` engine</span>
    <span class="s4">#     lookup.</span>
    <span class="s4">#   - ``save(self)`` --&gt; called to save file to disk</span>
    <span class="s4"># - Mostly mandatory (i.e. should at least exist)</span>
    <span class="s4">#   - book, cur_sheet, path</span>

    <span class="s4"># - Optional:</span>
    <span class="s4">#   - ``__init__(self, path, engine=None, **kwargs)`` --&gt; always called</span>
    <span class="s4">#     with path as first argument.</span>

    <span class="s4"># You also need to register the class with ``register_writer()``.</span>
    <span class="s4"># Technically, ExcelWriter implementations don't need to subclass</span>
    <span class="s4"># ExcelWriter.</span>
    <span class="s0">def </span><span class="s1">__new__(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">path: FilePath | WriteExcelBuffer | ExcelWriter</span><span class="s0">,</span>
        <span class="s1">engine: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">date_format: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">datetime_format: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">mode: str = </span><span class="s2">&quot;w&quot;</span><span class="s0">,</span>
        <span class="s1">storage_options: StorageOptions = </span><span class="s0">None,</span>
        <span class="s1">if_sheet_exists: Literal[</span><span class="s2">&quot;error&quot;</span><span class="s0">, </span><span class="s2">&quot;new&quot;</span><span class="s0">, </span><span class="s2">&quot;replace&quot;</span><span class="s0">, </span><span class="s2">&quot;overlay&quot;</span><span class="s1">] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">engine_kwargs: dict | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">kwargs:</span>
            <span class="s0">if </span><span class="s1">engine_kwargs </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Cannot use both engine_kwargs and **kwargs&quot;</span><span class="s1">)</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;Use of **kwargs is deprecated, use engine_kwargs instead.&quot;</span><span class="s0">,</span>
                <span class="s1">FutureWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s4"># only switch class if generic(ExcelWriter)</span>

        <span class="s0">if </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">ExcelWriter:</span>
            <span class="s0">if </span><span class="s1">engine </span><span class="s0">is None or </span><span class="s1">(isinstance(engine</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">engine == </span><span class="s2">&quot;auto&quot;</span><span class="s1">):</span>
                <span class="s0">if </span><span class="s1">isinstance(path</span><span class="s0">, </span><span class="s1">str):</span>
                    <span class="s1">ext = os.path.splitext(path)[-</span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">ext = </span><span class="s2">&quot;xlsx&quot;</span>

                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">engine = config.get_option(</span><span class="s2">f&quot;io.excel.</span><span class="s0">{</span><span class="s1">ext</span><span class="s0">}</span><span class="s2">.writer&quot;</span><span class="s0">, </span><span class="s1">silent=</span><span class="s0">True</span><span class="s1">)</span>
                    <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;auto&quot;</span><span class="s1">:</span>
                        <span class="s1">engine = get_default_engine(ext</span><span class="s0">, </span><span class="s1">mode=</span><span class="s2">&quot;writer&quot;</span><span class="s1">)</span>
                <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">err:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;No engine for filetype: '</span><span class="s0">{</span><span class="s1">ext</span><span class="s0">}</span><span class="s2">'&quot;</span><span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>

            <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;xlwt&quot;</span><span class="s1">:</span>
                <span class="s1">xls_config_engine = config.get_option(</span>
                    <span class="s2">&quot;io.excel.xls.writer&quot;</span><span class="s0">, </span><span class="s1">silent=</span><span class="s0">True</span>
                <span class="s1">)</span>
                <span class="s4"># Don't warn a 2nd time if user has changed the default engine for xls</span>
                <span class="s0">if </span><span class="s1">xls_config_engine != </span><span class="s2">&quot;xlwt&quot;</span><span class="s1">:</span>
                    <span class="s1">warnings.warn(</span>
                        <span class="s2">&quot;As the xlwt package is no longer maintained, the xlwt &quot;</span>
                        <span class="s2">&quot;engine will be removed in a future version of pandas. &quot;</span>
                        <span class="s2">&quot;This is the only engine in pandas that supports writing &quot;</span>
                        <span class="s2">&quot;in the xls format. Install openpyxl and write to an xlsx &quot;</span>
                        <span class="s2">&quot;file instead. You can set the option io.excel.xls.writer &quot;</span>
                        <span class="s2">&quot;to 'xlwt' to silence this warning. While this option is &quot;</span>
                        <span class="s2">&quot;deprecated and will also raise a warning, it can &quot;</span>
                        <span class="s2">&quot;be globally set and the warning suppressed.&quot;</span><span class="s0">,</span>
                        <span class="s1">FutureWarning</span><span class="s0">,</span>
                        <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
                    <span class="s1">)</span>

            <span class="s4"># for mypy</span>
            <span class="s0">assert </span><span class="s1">engine </span><span class="s0">is not None</span>
            <span class="s1">cls = get_writer(engine)</span>

        <span class="s0">return </span><span class="s1">object.__new__(cls)</span>

    <span class="s4"># declare external properties you can count on</span>
    <span class="s1">path = </span><span class="s0">None</span>

    <span class="s1">@property</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">supported_extensions(self) -&gt; tuple[str</span><span class="s0">, </span><span class="s1">...] | list[str]:</span>
        <span class="s5">&quot;&quot;&quot;Extensions that writer engine supports.&quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s1">@property</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">engine(self) -&gt; str:</span>
        <span class="s5">&quot;&quot;&quot;Name of engine.&quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">write_cells(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">cells</span><span class="s0">,</span>
        <span class="s1">sheet_name: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">startrow: int = </span><span class="s3">0</span><span class="s0">,</span>
        <span class="s1">startcol: int = </span><span class="s3">0</span><span class="s0">,</span>
        <span class="s1">freeze_panes: tuple[int</span><span class="s0">, </span><span class="s1">int] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Write given formatted cells into Excel an excel sheet 
 
        Parameters 
        ---------- 
        cells : generator 
            cell of formatted data to save to Excel sheet 
        sheet_name : str, default None 
            Name of Excel sheet, if None, then use self.cur_sheet 
        startrow : upper left cell row to dump data frame 
        startcol : upper left cell column to dump data frame 
        freeze_panes: int tuple of length 2 
            contains the bottom-most row and right-most column to freeze 
        &quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s1">@abc.abstractmethod</span>
    <span class="s0">def </span><span class="s1">save(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Save workbook to disk. 
        &quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">path: FilePath | WriteExcelBuffer | ExcelWriter</span><span class="s0">,</span>
        <span class="s1">engine: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">date_format: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">datetime_format: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">mode: str = </span><span class="s2">&quot;w&quot;</span><span class="s0">,</span>
        <span class="s1">storage_options: StorageOptions = </span><span class="s0">None,</span>
        <span class="s1">if_sheet_exists: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">engine_kwargs: dict | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s4"># validate that this engine can handle the extension</span>
        <span class="s0">if </span><span class="s1">isinstance(path</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">ext = os.path.splitext(path)[-</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">self.check_extension(ext)</span>

        <span class="s4"># use mode to open the file</span>
        <span class="s0">if </span><span class="s2">&quot;b&quot; </span><span class="s0">not in </span><span class="s1">mode:</span>
            <span class="s1">mode += </span><span class="s2">&quot;b&quot;</span>
        <span class="s4"># use &quot;a&quot; for the user to append data to excel but internally use &quot;r+&quot; to let</span>
        <span class="s4"># the excel backend first read the existing file and then write any data to it</span>
        <span class="s1">mode = mode.replace(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;r+&quot;</span><span class="s1">)</span>

        <span class="s4"># cast ExcelWriter to avoid adding 'if self.handles is not None'</span>
        <span class="s1">self.handles = IOHandles(</span>
            <span class="s1">cast(IO[bytes]</span><span class="s0">, </span><span class="s1">path)</span><span class="s0">, </span><span class="s1">compression={</span><span class="s2">&quot;compression&quot;</span><span class="s1">: </span><span class="s0">None</span><span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">isinstance(path</span><span class="s0">, </span><span class="s1">ExcelWriter):</span>
            <span class="s1">self.handles = get_handle(</span>
                <span class="s1">path</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">storage_options=storage_options</span><span class="s0">, </span><span class="s1">is_text=</span><span class="s0">False</span>
            <span class="s1">)</span>
        <span class="s1">self.sheets: dict[str</span><span class="s0">, </span><span class="s1">Any] = {}</span>
        <span class="s1">self.cur_sheet = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">date_format </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.date_format = </span><span class="s2">&quot;YYYY-MM-DD&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.date_format = date_format</span>
        <span class="s0">if </span><span class="s1">datetime_format </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.datetime_format = </span><span class="s2">&quot;YYYY-MM-DD HH:MM:SS&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.datetime_format = datetime_format</span>

        <span class="s1">self.mode = mode</span>

        <span class="s0">if </span><span class="s1">if_sheet_exists </span><span class="s0">not in </span><span class="s1">(</span><span class="s0">None, </span><span class="s2">&quot;error&quot;</span><span class="s0">, </span><span class="s2">&quot;new&quot;</span><span class="s0">, </span><span class="s2">&quot;replace&quot;</span><span class="s0">, </span><span class="s2">&quot;overlay&quot;</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">f&quot;'</span><span class="s0">{</span><span class="s1">if_sheet_exists</span><span class="s0">}</span><span class="s2">' is not valid for if_sheet_exists. &quot;</span>
                <span class="s2">&quot;Valid options are 'error', 'new', 'replace' and 'overlay'.&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">if_sheet_exists </span><span class="s0">and </span><span class="s2">&quot;r+&quot; </span><span class="s0">not in </span><span class="s1">mode:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;if_sheet_exists is only valid in append mode (mode='a')&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">if_sheet_exists </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">if_sheet_exists = </span><span class="s2">&quot;error&quot;</span>
        <span class="s1">self.if_sheet_exists = if_sheet_exists</span>

    <span class="s0">def </span><span class="s1">__fspath__(self):</span>
        <span class="s0">return </span><span class="s1">getattr(self.handles.handle</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_get_sheet_name(self</span><span class="s0">, </span><span class="s1">sheet_name: str | </span><span class="s0">None</span><span class="s1">) -&gt; str:</span>
        <span class="s0">if </span><span class="s1">sheet_name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">sheet_name = self.cur_sheet</span>
        <span class="s0">if </span><span class="s1">sheet_name </span><span class="s0">is None</span><span class="s1">:  </span><span class="s4"># pragma: no cover</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Must pass explicit sheet_name or set cur_sheet property&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">sheet_name</span>

    <span class="s0">def </span><span class="s1">_value_with_fmt(self</span><span class="s0">, </span><span class="s1">val) -&gt; tuple[object</span><span class="s0">, </span><span class="s1">str | </span><span class="s0">None</span><span class="s1">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert numpy types to Python types for the Excel writers. 
 
        Parameters 
        ---------- 
        val : object 
            Value to be written into cells 
 
        Returns 
        ------- 
        Tuple with the first element being the converted value and the second 
            being an optional format 
        &quot;&quot;&quot;</span>
        <span class="s1">fmt = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">is_integer(val):</span>
            <span class="s1">val = int(val)</span>
        <span class="s0">elif </span><span class="s1">is_float(val):</span>
            <span class="s1">val = float(val)</span>
        <span class="s0">elif </span><span class="s1">is_bool(val):</span>
            <span class="s1">val = bool(val)</span>
        <span class="s0">elif </span><span class="s1">isinstance(val</span><span class="s0">, </span><span class="s1">datetime.datetime):</span>
            <span class="s1">fmt = self.datetime_format</span>
        <span class="s0">elif </span><span class="s1">isinstance(val</span><span class="s0">, </span><span class="s1">datetime.date):</span>
            <span class="s1">fmt = self.date_format</span>
        <span class="s0">elif </span><span class="s1">isinstance(val</span><span class="s0">, </span><span class="s1">datetime.timedelta):</span>
            <span class="s1">val = val.total_seconds() / </span><span class="s3">86400</span>
            <span class="s1">fmt = </span><span class="s2">&quot;0&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">val = str(val)</span>

        <span class="s0">return </span><span class="s1">val</span><span class="s0">, </span><span class="s1">fmt</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">check_extension(cls</span><span class="s0">, </span><span class="s1">ext: str) -&gt; Literal[</span><span class="s0">True</span><span class="s1">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        checks that path's extension against the Writer's supported 
        extensions.  If it isn't supported, raises UnsupportedFiletypeError. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">ext.startswith(</span><span class="s2">&quot;.&quot;</span><span class="s1">):</span>
            <span class="s1">ext = ext[</span><span class="s3">1</span><span class="s1">:]</span>
        <span class="s4"># error: &quot;Callable[[ExcelWriter], Any]&quot; has no attribute &quot;__iter__&quot; (not</span>
        <span class="s4">#  iterable)</span>
        <span class="s0">if not </span><span class="s1">any(</span>
            <span class="s1">ext </span><span class="s0">in </span><span class="s1">extension</span>
            <span class="s0">for </span><span class="s1">extension </span><span class="s0">in </span><span class="s1">cls.supported_extensions  </span><span class="s4"># type: ignore[attr-defined]</span>
        <span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;Invalid extension for engine '</span><span class="s0">{</span><span class="s1">cls.engine</span><span class="s0">}</span><span class="s2">': '</span><span class="s0">{</span><span class="s1">ext</span><span class="s0">}</span><span class="s2">'&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return True</span>

    <span class="s4"># Allow use as a contextmanager</span>
    <span class="s0">def </span><span class="s1">__enter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(self</span><span class="s0">, </span><span class="s1">exc_type</span><span class="s0">, </span><span class="s1">exc_value</span><span class="s0">, </span><span class="s1">traceback):</span>
        <span class="s1">self.close()</span>

    <span class="s0">def </span><span class="s1">close(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;synonym for save, to make it more file-like&quot;&quot;&quot;</span>
        <span class="s1">self.save()</span>
        <span class="s1">self.handles.close()</span>


<span class="s1">XLS_SIGNATURES = (</span>
    <span class="s6">b&quot;</span><span class="s0">\x09\x00\x04\x00\x07\x00\x10\x00</span><span class="s6">&quot;</span><span class="s0">,  </span><span class="s4"># BIFF2</span>
    <span class="s6">b&quot;</span><span class="s0">\x09\x02\x06\x00\x00\x00\x10\x00</span><span class="s6">&quot;</span><span class="s0">,  </span><span class="s4"># BIFF3</span>
    <span class="s6">b&quot;</span><span class="s0">\x09\x04\x06\x00\x00\x00\x10\x00</span><span class="s6">&quot;</span><span class="s0">,  </span><span class="s4"># BIFF4</span>
    <span class="s6">b&quot;</span><span class="s0">\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1</span><span class="s6">&quot;</span><span class="s0">,  </span><span class="s4"># Compound File Binary</span>
<span class="s1">)</span>
<span class="s1">ZIP_SIGNATURE = </span><span class="s6">b&quot;PK</span><span class="s0">\x03\x04</span><span class="s6">&quot;</span>
<span class="s1">PEEK_SIZE = max(map(len</span><span class="s0">, </span><span class="s1">XLS_SIGNATURES + (ZIP_SIGNATURE</span><span class="s0">,</span><span class="s1">)))</span>


<span class="s1">@doc(storage_options=_shared_docs[</span><span class="s2">&quot;storage_options&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">inspect_excel_format(</span>
    <span class="s1">content_or_path: FilePath | ReadBuffer[bytes]</span><span class="s0">,</span>
    <span class="s1">storage_options: StorageOptions = </span><span class="s0">None,</span>
<span class="s1">) -&gt; str | </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Inspect the path or content of an excel file and get its format. 
 
    Adopted from xlrd: https://github.com/python-excel/xlrd. 
 
    Parameters 
    ---------- 
    content_or_path : str or file-like object 
        Path to file or content of file to inspect. May be a URL. 
    {storage_options} 
 
    Returns 
    ------- 
    str or None 
        Format of file if it can be determined. 
 
    Raises 
    ------ 
    ValueError 
        If resulting stream is empty. 
    BadZipFile 
        If resulting stream does not have an XLS signature and is not a valid zipfile. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(content_or_path</span><span class="s0">, </span><span class="s1">bytes):</span>
        <span class="s1">content_or_path = BytesIO(content_or_path)</span>

    <span class="s0">with </span><span class="s1">get_handle(</span>
        <span class="s1">content_or_path</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s0">, </span><span class="s1">storage_options=storage_options</span><span class="s0">, </span><span class="s1">is_text=</span><span class="s0">False</span>
    <span class="s1">) </span><span class="s0">as </span><span class="s1">handle:</span>
        <span class="s1">stream = handle.handle</span>
        <span class="s1">stream.seek(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">buf = stream.read(PEEK_SIZE)</span>
        <span class="s0">if </span><span class="s1">buf </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;stream is empty&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">isinstance(buf</span><span class="s0">, </span><span class="s1">bytes)</span>
            <span class="s1">peek = buf</span>
        <span class="s1">stream.seek(</span><span class="s3">0</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">any(peek.startswith(sig) </span><span class="s0">for </span><span class="s1">sig </span><span class="s0">in </span><span class="s1">XLS_SIGNATURES):</span>
            <span class="s0">return </span><span class="s2">&quot;xls&quot;</span>
        <span class="s0">elif not </span><span class="s1">peek.startswith(ZIP_SIGNATURE):</span>
            <span class="s0">return None</span>

        <span class="s1">zf = zipfile.ZipFile(stream)</span>

        <span class="s4"># Workaround for some third party files that use forward slashes and</span>
        <span class="s4"># lower case names.</span>
        <span class="s1">component_names = [name.replace(</span><span class="s2">&quot;</span><span class="s0">\\</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;/&quot;</span><span class="s1">).lower() </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">zf.namelist()]</span>

        <span class="s0">if </span><span class="s2">&quot;xl/workbook.xml&quot; </span><span class="s0">in </span><span class="s1">component_names:</span>
            <span class="s0">return </span><span class="s2">&quot;xlsx&quot;</span>
        <span class="s0">if </span><span class="s2">&quot;xl/workbook.bin&quot; </span><span class="s0">in </span><span class="s1">component_names:</span>
            <span class="s0">return </span><span class="s2">&quot;xlsb&quot;</span>
        <span class="s0">if </span><span class="s2">&quot;content.xml&quot; </span><span class="s0">in </span><span class="s1">component_names:</span>
            <span class="s0">return </span><span class="s2">&quot;ods&quot;</span>
        <span class="s0">return </span><span class="s2">&quot;zip&quot;</span>


<span class="s0">class </span><span class="s1">ExcelFile:</span>
    <span class="s5">&quot;&quot;&quot; 
    Class for parsing tabular excel sheets into DataFrame objects. 
 
    See read_excel for more documentation. 
 
    Parameters 
    ---------- 
    path_or_buffer : str, bytes, path object (pathlib.Path or py._path.local.LocalPath), 
        a file-like object, xlrd workbook or openpyxl workbook. 
        If a string or path object, expected to be a path to a 
        .xls, .xlsx, .xlsb, .xlsm, .odf, .ods, or .odt file. 
    engine : str, default None 
        If io is not a buffer or path, this must be set to identify io. 
        Supported engines: ``xlrd``, ``openpyxl``, ``odf``, ``pyxlsb`` 
        Engine compatibility : 
 
        - ``xlrd`` supports old-style Excel files (.xls). 
        - ``openpyxl`` supports newer Excel file formats. 
        - ``odf`` supports OpenDocument file formats (.odf, .ods, .odt). 
        - ``pyxlsb`` supports Binary Excel files. 
 
        .. versionchanged:: 1.2.0 
 
           The engine `xlrd &lt;https://xlrd.readthedocs.io/en/latest/&gt;`_ 
           now only supports old-style ``.xls`` files. 
           When ``engine=None``, the following logic will be 
           used to determine the engine: 
 
           - If ``path_or_buffer`` is an OpenDocument format (.odf, .ods, .odt), 
             then `odf &lt;https://pypi.org/project/odfpy/&gt;`_ will be used. 
           - Otherwise if ``path_or_buffer`` is an xls format, 
             ``xlrd`` will be used. 
           - Otherwise if ``path_or_buffer`` is in xlsb format, 
             `pyxlsb &lt;https://pypi.org/project/pyxlsb/&gt;`_ will be used. 
 
           .. versionadded:: 1.3.0 
           - Otherwise if `openpyxl &lt;https://pypi.org/project/openpyxl/&gt;`_ is installed, 
             then ``openpyxl`` will be used. 
           - Otherwise if ``xlrd &gt;= 2.0`` is installed, a ``ValueError`` will be raised. 
           - Otherwise ``xlrd`` will be used and a ``FutureWarning`` will be raised. 
             This case will raise a ``ValueError`` in a future version of pandas. 
 
           .. warning:: 
 
            Please do not report issues when using ``xlrd`` to read ``.xlsx`` files. 
            This is not supported, switch to using ``openpyxl`` instead. 
    &quot;&quot;&quot;</span>

    <span class="s0">from </span><span class="s1">pandas.io.excel._odfreader </span><span class="s0">import </span><span class="s1">ODFReader</span>
    <span class="s0">from </span><span class="s1">pandas.io.excel._openpyxl </span><span class="s0">import </span><span class="s1">OpenpyxlReader</span>
    <span class="s0">from </span><span class="s1">pandas.io.excel._pyxlsb </span><span class="s0">import </span><span class="s1">PyxlsbReader</span>
    <span class="s0">from </span><span class="s1">pandas.io.excel._xlrd </span><span class="s0">import </span><span class="s1">XlrdReader</span>

    <span class="s1">_engines: Mapping[str</span><span class="s0">, </span><span class="s1">Any] = {</span>
        <span class="s2">&quot;xlrd&quot;</span><span class="s1">: XlrdReader</span><span class="s0">,</span>
        <span class="s2">&quot;openpyxl&quot;</span><span class="s1">: OpenpyxlReader</span><span class="s0">,</span>
        <span class="s2">&quot;odf&quot;</span><span class="s1">: ODFReader</span><span class="s0">,</span>
        <span class="s2">&quot;pyxlsb&quot;</span><span class="s1">: PyxlsbReader</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">path_or_buffer</span><span class="s0">,</span>
        <span class="s1">engine: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">storage_options: StorageOptions = </span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">engine </span><span class="s0">is not None and </span><span class="s1">engine </span><span class="s0">not in </span><span class="s1">self._engines:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;Unknown engine: </span><span class="s0">{</span><span class="s1">engine</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

        <span class="s4"># First argument can also be bytes, so create a buffer</span>
        <span class="s0">if </span><span class="s1">isinstance(path_or_buffer</span><span class="s0">, </span><span class="s1">bytes):</span>
            <span class="s1">path_or_buffer = BytesIO(path_or_buffer)</span>

        <span class="s4"># Could be a str, ExcelFile, Book, etc.</span>
        <span class="s1">self.io = path_or_buffer</span>
        <span class="s4"># Always a string</span>
        <span class="s1">self._io = stringify_path(path_or_buffer)</span>

        <span class="s4"># Determine xlrd version if installed</span>
        <span class="s0">if </span><span class="s1">import_optional_dependency(</span><span class="s2">&quot;xlrd&quot;</span><span class="s0">, </span><span class="s1">errors=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">xlrd_version = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">import </span><span class="s1">xlrd</span>

            <span class="s1">xlrd_version = Version(get_version(xlrd))</span>

        <span class="s1">ext = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">engine </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s4"># Only determine ext if it is needed</span>
            <span class="s0">if </span><span class="s1">xlrd_version </span><span class="s0">is not None and </span><span class="s1">isinstance(path_or_buffer</span><span class="s0">, </span><span class="s1">xlrd.Book):</span>
                <span class="s1">ext = </span><span class="s2">&quot;xls&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">ext = inspect_excel_format(</span>
                    <span class="s1">content_or_path=path_or_buffer</span><span class="s0">, </span><span class="s1">storage_options=storage_options</span>
                <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">ext </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span>
                        <span class="s2">&quot;Excel file format cannot be determined, you must specify &quot;</span>
                        <span class="s2">&quot;an engine manually.&quot;</span>
                    <span class="s1">)</span>

            <span class="s1">engine = config.get_option(</span><span class="s2">f&quot;io.excel.</span><span class="s0">{</span><span class="s1">ext</span><span class="s0">}</span><span class="s2">.reader&quot;</span><span class="s0">, </span><span class="s1">silent=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;auto&quot;</span><span class="s1">:</span>
                <span class="s1">engine = get_default_engine(ext</span><span class="s0">, </span><span class="s1">mode=</span><span class="s2">&quot;reader&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;xlrd&quot; </span><span class="s0">and </span><span class="s1">xlrd_version </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">ext </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s4"># Need ext to determine ext in order to raise/warn</span>
                <span class="s0">if </span><span class="s1">isinstance(path_or_buffer</span><span class="s0">, </span><span class="s1">xlrd.Book):</span>
                    <span class="s1">ext = </span><span class="s2">&quot;xls&quot;</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">ext = inspect_excel_format(</span>
                        <span class="s1">path_or_buffer</span><span class="s0">, </span><span class="s1">storage_options=storage_options</span>
                    <span class="s1">)</span>

            <span class="s4"># Pass through if ext is None, otherwise check if ext valid for xlrd</span>
            <span class="s0">if </span><span class="s1">ext </span><span class="s0">and </span><span class="s1">ext != </span><span class="s2">&quot;xls&quot; </span><span class="s0">and </span><span class="s1">xlrd_version &gt;= Version(</span><span class="s2">&quot;2&quot;</span><span class="s1">):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">f&quot;Your version of xlrd is </span><span class="s0">{</span><span class="s1">xlrd_version</span><span class="s0">}</span><span class="s2">. In xlrd &gt;= 2.0, &quot;</span>
                    <span class="s2">f&quot;only the xls format is supported. Install openpyxl instead.&quot;</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">ext </span><span class="s0">and </span><span class="s1">ext != </span><span class="s2">&quot;xls&quot;</span><span class="s1">:</span>
                <span class="s1">stacklevel = find_stack_level()</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s2">f&quot;Your version of xlrd is </span><span class="s0">{</span><span class="s1">xlrd_version</span><span class="s0">}</span><span class="s2">. In xlrd &gt;= 2.0, &quot;</span>
                    <span class="s2">f&quot;only the xls format is supported. Install &quot;</span>
                    <span class="s2">f&quot;openpyxl instead.&quot;</span><span class="s0">,</span>
                    <span class="s1">FutureWarning</span><span class="s0">,</span>
                    <span class="s1">stacklevel=stacklevel</span><span class="s0">,</span>
                <span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">engine </span><span class="s0">is not None</span>
        <span class="s1">self.engine = engine</span>
        <span class="s1">self.storage_options = storage_options</span>

        <span class="s1">self._reader = self._engines[engine](self._io</span><span class="s0">, </span><span class="s1">storage_options=storage_options)</span>

    <span class="s0">def </span><span class="s1">__fspath__(self):</span>
        <span class="s0">return </span><span class="s1">self._io</span>

    <span class="s0">def </span><span class="s1">parse(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">sheet_name: str | int | list[int] | list[str] | </span><span class="s0">None </span><span class="s1">= </span><span class="s3">0</span><span class="s0">,</span>
        <span class="s1">header: int | Sequence[int] | </span><span class="s0">None </span><span class="s1">= </span><span class="s3">0</span><span class="s0">,</span>
        <span class="s1">names=</span><span class="s0">None,</span>
        <span class="s1">index_col: int | Sequence[int] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">usecols=</span><span class="s0">None,</span>
        <span class="s1">squeeze: bool | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">converters=</span><span class="s0">None,</span>
        <span class="s1">true_values: Iterable[Hashable] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">false_values: Iterable[Hashable] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">skiprows: Sequence[int] | int | Callable[[int]</span><span class="s0">, </span><span class="s1">object] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">nrows: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">na_values=</span><span class="s0">None,</span>
        <span class="s1">parse_dates=</span><span class="s0">False,</span>
        <span class="s1">date_parser=</span><span class="s0">None,</span>
        <span class="s1">thousands: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">comment: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">skipfooter: int = </span><span class="s3">0</span><span class="s0">,</span>
        <span class="s1">convert_float: bool | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">mangle_dupe_cols: bool = </span><span class="s0">True,</span>
        <span class="s1">**kwds</span><span class="s0">,</span>
    <span class="s1">) -&gt; DataFrame | dict[str</span><span class="s0">, </span><span class="s1">DataFrame] | dict[int</span><span class="s0">, </span><span class="s1">DataFrame]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Parse specified sheet(s) into a DataFrame. 
 
        Equivalent to read_excel(ExcelFile, ...)  See the read_excel 
        docstring for more info on accepted parameters. 
 
        Returns 
        ------- 
        DataFrame or dict of DataFrames 
            DataFrame from the passed in Excel file. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._reader.parse(</span>
            <span class="s1">sheet_name=sheet_name</span><span class="s0">,</span>
            <span class="s1">header=header</span><span class="s0">,</span>
            <span class="s1">names=names</span><span class="s0">,</span>
            <span class="s1">index_col=index_col</span><span class="s0">,</span>
            <span class="s1">usecols=usecols</span><span class="s0">,</span>
            <span class="s1">squeeze=squeeze</span><span class="s0">,</span>
            <span class="s1">converters=converters</span><span class="s0">,</span>
            <span class="s1">true_values=true_values</span><span class="s0">,</span>
            <span class="s1">false_values=false_values</span><span class="s0">,</span>
            <span class="s1">skiprows=skiprows</span><span class="s0">,</span>
            <span class="s1">nrows=nrows</span><span class="s0">,</span>
            <span class="s1">na_values=na_values</span><span class="s0">,</span>
            <span class="s1">parse_dates=parse_dates</span><span class="s0">,</span>
            <span class="s1">date_parser=date_parser</span><span class="s0">,</span>
            <span class="s1">thousands=thousands</span><span class="s0">,</span>
            <span class="s1">comment=comment</span><span class="s0">,</span>
            <span class="s1">skipfooter=skipfooter</span><span class="s0">,</span>
            <span class="s1">convert_float=convert_float</span><span class="s0">,</span>
            <span class="s1">mangle_dupe_cols=mangle_dupe_cols</span><span class="s0">,</span>
            <span class="s1">**kwds</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">book(self):</span>
        <span class="s0">return </span><span class="s1">self._reader.book</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">sheet_names(self):</span>
        <span class="s0">return </span><span class="s1">self._reader.sheet_names</span>

    <span class="s0">def </span><span class="s1">close(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;close io if necessary&quot;&quot;&quot;</span>
        <span class="s1">self._reader.close()</span>

    <span class="s0">def </span><span class="s1">__enter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(self</span><span class="s0">, </span><span class="s1">exc_type</span><span class="s0">, </span><span class="s1">exc_value</span><span class="s0">, </span><span class="s1">traceback):</span>
        <span class="s1">self.close()</span>

    <span class="s0">def </span><span class="s1">__del__(self):</span>
        <span class="s4"># Ensure we don't leak file descriptors, but put in try/except in case</span>
        <span class="s4"># attributes are already deleted</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.close()</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s0">pass</span>
</pre>
</body>
</html>