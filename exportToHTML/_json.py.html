<html>
<head>
<title>_json.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_json.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">abc </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ABC</span><span class="s0">,</span>
    <span class="s1">abstractmethod</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">abc</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">StringIO</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">islice</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">Mapping</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">import </span><span class="s1">pandas._libs.json </span><span class="s0">as </span><span class="s1">json</span>
<span class="s0">from </span><span class="s1">pandas._libs.tslibs </span><span class="s0">import </span><span class="s1">iNaT</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">CompressionOptions</span><span class="s0">,</span>
    <span class="s1">DtypeArg</span><span class="s0">,</span>
    <span class="s1">IndexLabel</span><span class="s0">,</span>
    <span class="s1">JSONSerializable</span><span class="s0">,</span>
    <span class="s1">StorageOptions</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.errors </span><span class="s0">import </span><span class="s1">AbstractMethodError</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">deprecate_kwarg</span><span class="s0">,</span>
    <span class="s1">deprecate_nonkeyword_arguments</span><span class="s0">,</span>
    <span class="s1">doc</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ensure_str</span><span class="s0">,</span>
    <span class="s1">is_period_dtype</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">MultiIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">isna</span><span class="s0">,</span>
    <span class="s1">notna</span><span class="s0">,</span>
    <span class="s1">to_datetime</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.construction </span><span class="s0">import </span><span class="s1">create_series_with_explicit_dtype</span>
<span class="s0">from </span><span class="s1">pandas.core.generic </span><span class="s0">import </span><span class="s1">NDFrame</span>
<span class="s0">from </span><span class="s1">pandas.core.reshape.concat </span><span class="s0">import </span><span class="s1">concat</span>
<span class="s0">from </span><span class="s1">pandas.core.shared_docs </span><span class="s0">import </span><span class="s1">_shared_docs</span>

<span class="s0">from </span><span class="s1">pandas.io.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">IOHandles</span><span class="s0">,</span>
    <span class="s1">file_exists</span><span class="s0">,</span>
    <span class="s1">get_handle</span><span class="s0">,</span>
    <span class="s1">is_fsspec_url</span><span class="s0">,</span>
    <span class="s1">is_url</span><span class="s0">,</span>
    <span class="s1">stringify_path</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.io.json._normalize </span><span class="s0">import </span><span class="s1">convert_to_line_delimits</span>
<span class="s0">from </span><span class="s1">pandas.io.json._table_schema </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">build_table_schema</span><span class="s0">,</span>
    <span class="s1">parse_table_schema</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.io.parsers.readers </span><span class="s0">import </span><span class="s1">validate_integer</span>

<span class="s1">loads = json.loads</span>
<span class="s1">dumps = json.dumps</span>


<span class="s2"># interface to/from</span>
<span class="s0">def </span><span class="s1">to_json(</span>
    <span class="s1">path_or_buf</span><span class="s0">,</span>
    <span class="s1">obj: NDFrame</span><span class="s0">,</span>
    <span class="s1">orient: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">date_format: str = </span><span class="s3">&quot;epoch&quot;</span><span class="s0">,</span>
    <span class="s1">double_precision: int = </span><span class="s4">10</span><span class="s0">,</span>
    <span class="s1">force_ascii: bool = </span><span class="s0">True,</span>
    <span class="s1">date_unit: str = </span><span class="s3">&quot;ms&quot;</span><span class="s0">,</span>
    <span class="s1">default_handler: Callable[[Any]</span><span class="s0">, </span><span class="s1">JSONSerializable] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">lines: bool = </span><span class="s0">False,</span>
    <span class="s1">compression: CompressionOptions = </span><span class="s3">&quot;infer&quot;</span><span class="s0">,</span>
    <span class="s1">index: bool = </span><span class="s0">True,</span>
    <span class="s1">indent: int = </span><span class="s4">0</span><span class="s0">,</span>
    <span class="s1">storage_options: StorageOptions = </span><span class="s0">None,</span>
<span class="s1">):</span>

    <span class="s0">if not </span><span class="s1">index </span><span class="s0">and </span><span class="s1">orient </span><span class="s0">not in </span><span class="s1">[</span><span class="s3">&quot;split&quot;</span><span class="s0">, </span><span class="s3">&quot;table&quot;</span><span class="s1">]:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;'index=False' is only valid when 'orient' is 'split' or 'table'&quot;</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">lines </span><span class="s0">and </span><span class="s1">orient != </span><span class="s3">&quot;records&quot;</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'lines' keyword only valid when 'orient' is records&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">orient == </span><span class="s3">&quot;table&quot; </span><span class="s0">and </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">Series):</span>
        <span class="s1">obj = obj.to_frame(name=obj.name </span><span class="s0">or </span><span class="s3">&quot;values&quot;</span><span class="s1">)</span>

    <span class="s1">writer: type[Writer]</span>
    <span class="s0">if </span><span class="s1">orient == </span><span class="s3">&quot;table&quot; </span><span class="s0">and </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">DataFrame):</span>
        <span class="s1">writer = JSONTableWriter</span>
    <span class="s0">elif </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">Series):</span>
        <span class="s1">writer = SeriesWriter</span>
    <span class="s0">elif </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">DataFrame):</span>
        <span class="s1">writer = FrameWriter</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;'obj' should be a Series or a DataFrame&quot;</span><span class="s1">)</span>

    <span class="s1">s = writer(</span>
        <span class="s1">obj</span><span class="s0">,</span>
        <span class="s1">orient=orient</span><span class="s0">,</span>
        <span class="s1">date_format=date_format</span><span class="s0">,</span>
        <span class="s1">double_precision=double_precision</span><span class="s0">,</span>
        <span class="s1">ensure_ascii=force_ascii</span><span class="s0">,</span>
        <span class="s1">date_unit=date_unit</span><span class="s0">,</span>
        <span class="s1">default_handler=default_handler</span><span class="s0">,</span>
        <span class="s1">index=index</span><span class="s0">,</span>
        <span class="s1">indent=indent</span><span class="s0">,</span>
    <span class="s1">).write()</span>

    <span class="s0">if </span><span class="s1">lines:</span>
        <span class="s1">s = convert_to_line_delimits(s)</span>

    <span class="s0">if </span><span class="s1">path_or_buf </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s2"># apply compression and byte/text conversion</span>
        <span class="s0">with </span><span class="s1">get_handle(</span>
            <span class="s1">path_or_buf</span><span class="s0">, </span><span class="s3">&quot;w&quot;</span><span class="s0">, </span><span class="s1">compression=compression</span><span class="s0">, </span><span class="s1">storage_options=storage_options</span>
        <span class="s1">) </span><span class="s0">as </span><span class="s1">handles:</span>
            <span class="s1">handles.handle.write(s)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">s</span>


<span class="s0">class </span><span class="s1">Writer(ABC):</span>
    <span class="s1">_default_orient: str</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">obj</span><span class="s0">,</span>
        <span class="s1">orient: str | </span><span class="s0">None,</span>
        <span class="s1">date_format: str</span><span class="s0">,</span>
        <span class="s1">double_precision: int</span><span class="s0">,</span>
        <span class="s1">ensure_ascii: bool</span><span class="s0">,</span>
        <span class="s1">date_unit: str</span><span class="s0">,</span>
        <span class="s1">index: bool</span><span class="s0">,</span>
        <span class="s1">default_handler: Callable[[Any]</span><span class="s0">, </span><span class="s1">JSONSerializable] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">indent: int = </span><span class="s4">0</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">self.obj = obj</span>

        <span class="s0">if </span><span class="s1">orient </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">orient = self._default_orient</span>

        <span class="s1">self.orient = orient</span>
        <span class="s1">self.date_format = date_format</span>
        <span class="s1">self.double_precision = double_precision</span>
        <span class="s1">self.ensure_ascii = ensure_ascii</span>
        <span class="s1">self.date_unit = date_unit</span>
        <span class="s1">self.default_handler = default_handler</span>
        <span class="s1">self.index = index</span>
        <span class="s1">self.indent = indent</span>

        <span class="s1">self.is_copy = </span><span class="s0">None</span>
        <span class="s1">self._format_axes()</span>

    <span class="s0">def </span><span class="s1">_format_axes(self):</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError(self)</span>

    <span class="s0">def </span><span class="s1">write(self):</span>
        <span class="s1">iso_dates = self.date_format == </span><span class="s3">&quot;iso&quot;</span>
        <span class="s0">return </span><span class="s1">dumps(</span>
            <span class="s1">self.obj_to_write</span><span class="s0">,</span>
            <span class="s1">orient=self.orient</span><span class="s0">,</span>
            <span class="s1">double_precision=self.double_precision</span><span class="s0">,</span>
            <span class="s1">ensure_ascii=self.ensure_ascii</span><span class="s0">,</span>
            <span class="s1">date_unit=self.date_unit</span><span class="s0">,</span>
            <span class="s1">iso_dates=iso_dates</span><span class="s0">,</span>
            <span class="s1">default_handler=self.default_handler</span><span class="s0">,</span>
            <span class="s1">indent=self.indent</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s1">@abstractmethod</span>
    <span class="s0">def </span><span class="s1">obj_to_write(self) -&gt; NDFrame | Mapping[IndexLabel</span><span class="s0">, </span><span class="s1">Any]:</span>
        <span class="s5">&quot;&quot;&quot;Object to write in JSON format.&quot;&quot;&quot;</span>
        <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">SeriesWriter(Writer):</span>
    <span class="s1">_default_orient = </span><span class="s3">&quot;index&quot;</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">obj_to_write(self) -&gt; NDFrame | Mapping[IndexLabel</span><span class="s0">, </span><span class="s1">Any]:</span>
        <span class="s0">if not </span><span class="s1">self.index </span><span class="s0">and </span><span class="s1">self.orient == </span><span class="s3">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">{</span><span class="s3">&quot;name&quot;</span><span class="s1">: self.obj.name</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s1">: self.obj.values}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.obj</span>

    <span class="s0">def </span><span class="s1">_format_axes(self):</span>
        <span class="s0">if not </span><span class="s1">self.obj.index.is_unique </span><span class="s0">and </span><span class="s1">self.orient == </span><span class="s3">&quot;index&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Series index must be unique for orient='</span><span class="s0">{</span><span class="s1">self.orient</span><span class="s0">}</span><span class="s3">'&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">FrameWriter(Writer):</span>
    <span class="s1">_default_orient = </span><span class="s3">&quot;columns&quot;</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">obj_to_write(self) -&gt; NDFrame | Mapping[IndexLabel</span><span class="s0">, </span><span class="s1">Any]:</span>
        <span class="s0">if not </span><span class="s1">self.index </span><span class="s0">and </span><span class="s1">self.orient == </span><span class="s3">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">obj_to_write = self.obj.to_dict(orient=</span><span class="s3">&quot;split&quot;</span><span class="s1">)</span>
            <span class="s0">del </span><span class="s1">obj_to_write[</span><span class="s3">&quot;index&quot;</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">obj_to_write = self.obj</span>
        <span class="s0">return </span><span class="s1">obj_to_write</span>

    <span class="s0">def </span><span class="s1">_format_axes(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Try to format axes if they are datelike. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self.obj.index.is_unique </span><span class="s0">and </span><span class="s1">self.orient </span><span class="s0">in </span><span class="s1">(</span><span class="s3">&quot;index&quot;</span><span class="s0">, </span><span class="s3">&quot;columns&quot;</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;DataFrame index must be unique for orient='</span><span class="s0">{</span><span class="s1">self.orient</span><span class="s0">}</span><span class="s3">'.&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">self.obj.columns.is_unique </span><span class="s0">and </span><span class="s1">self.orient </span><span class="s0">in </span><span class="s1">(</span>
            <span class="s3">&quot;index&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;columns&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;records&quot;</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;DataFrame columns must be unique for orient='</span><span class="s0">{</span><span class="s1">self.orient</span><span class="s0">}</span><span class="s3">'.&quot;</span>
            <span class="s1">)</span>


<span class="s0">class </span><span class="s1">JSONTableWriter(FrameWriter):</span>
    <span class="s1">_default_orient = </span><span class="s3">&quot;records&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">obj</span><span class="s0">,</span>
        <span class="s1">orient: str | </span><span class="s0">None,</span>
        <span class="s1">date_format: str</span><span class="s0">,</span>
        <span class="s1">double_precision: int</span><span class="s0">,</span>
        <span class="s1">ensure_ascii: bool</span><span class="s0">,</span>
        <span class="s1">date_unit: str</span><span class="s0">,</span>
        <span class="s1">index: bool</span><span class="s0">,</span>
        <span class="s1">default_handler: Callable[[Any]</span><span class="s0">, </span><span class="s1">JSONSerializable] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">indent: int = </span><span class="s4">0</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Adds a `schema` attribute with the Table Schema, resets 
        the index (can't do in caller, because the schema inference needs 
        to know what the index is, forces orient to records, and forces 
        date_format to 'iso'. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">obj</span><span class="s0">,</span>
            <span class="s1">orient</span><span class="s0">,</span>
            <span class="s1">date_format</span><span class="s0">,</span>
            <span class="s1">double_precision</span><span class="s0">,</span>
            <span class="s1">ensure_ascii</span><span class="s0">,</span>
            <span class="s1">date_unit</span><span class="s0">,</span>
            <span class="s1">index</span><span class="s0">,</span>
            <span class="s1">default_handler=default_handler</span><span class="s0">,</span>
            <span class="s1">indent=indent</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">date_format != </span><span class="s3">&quot;iso&quot;</span><span class="s1">:</span>
            <span class="s1">msg = (</span>
                <span class="s3">&quot;Trying to write with `orient='table'` and &quot;</span>
                <span class="s3">f&quot;`date_format='</span><span class="s0">{</span><span class="s1">date_format</span><span class="s0">}</span><span class="s3">'`. Table Schema requires dates &quot;</span>
                <span class="s3">&quot;to be formatted with `date_format='iso'`&quot;</span>
            <span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">self.schema = build_table_schema(obj</span><span class="s0">, </span><span class="s1">index=self.index)</span>

        <span class="s2"># NotImplemented on a column MultiIndex</span>
        <span class="s0">if </span><span class="s1">obj.ndim == </span><span class="s4">2 </span><span class="s0">and </span><span class="s1">isinstance(obj.columns</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s3">&quot;orient='table' is not supported for MultiIndex columns&quot;</span>
            <span class="s1">)</span>

        <span class="s2"># TODO: Do this timedelta properly in objToJSON.c See GH #15137</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">(obj.ndim == </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s0">and </span><span class="s1">(obj.name </span><span class="s0">in </span><span class="s1">set(obj.index.names))</span>
            <span class="s0">or </span><span class="s1">len(obj.columns.intersection(obj.index.names))</span>
        <span class="s1">):</span>
            <span class="s1">msg = </span><span class="s3">&quot;Overlapping names between the index and columns&quot;</span>
            <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">obj = obj.copy()</span>
        <span class="s1">timedeltas = obj.select_dtypes(include=[</span><span class="s3">&quot;timedelta&quot;</span><span class="s1">]).columns</span>
        <span class="s0">if </span><span class="s1">len(timedeltas):</span>
            <span class="s1">obj[timedeltas] = obj[timedeltas].applymap(</span><span class="s0">lambda </span><span class="s1">x: x.isoformat())</span>
        <span class="s2"># Convert PeriodIndex to datetimes before serializing</span>
        <span class="s0">if </span><span class="s1">is_period_dtype(obj.index.dtype):</span>
            <span class="s1">obj.index = obj.index.to_timestamp()</span>

        <span class="s2"># exclude index from obj if index=False</span>
        <span class="s0">if not </span><span class="s1">self.index:</span>
            <span class="s1">self.obj = obj.reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.obj = obj.reset_index(drop=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">self.date_format = </span><span class="s3">&quot;iso&quot;</span>
        <span class="s1">self.orient = </span><span class="s3">&quot;records&quot;</span>
        <span class="s1">self.index = index</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">obj_to_write(self) -&gt; NDFrame | Mapping[IndexLabel</span><span class="s0">, </span><span class="s1">Any]:</span>
        <span class="s0">return </span><span class="s1">{</span><span class="s3">&quot;schema&quot;</span><span class="s1">: self.schema</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s1">: self.obj}</span>


<span class="s1">@doc(</span>
    <span class="s1">storage_options=_shared_docs[</span><span class="s3">&quot;storage_options&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">decompression_options=_shared_docs[</span><span class="s3">&quot;decompression_options&quot;</span><span class="s1">] % </span><span class="s3">&quot;path_or_buf&quot;</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@deprecate_kwarg(old_arg_name=</span><span class="s3">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">new_arg_name=</span><span class="s0">None</span><span class="s1">)</span>
<span class="s1">@deprecate_nonkeyword_arguments(</span>
    <span class="s1">version=</span><span class="s3">&quot;2.0&quot;</span><span class="s0">, </span><span class="s1">allowed_args=[</span><span class="s3">&quot;path_or_buf&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">3</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">read_json(</span>
    <span class="s1">path_or_buf=</span><span class="s0">None,</span>
    <span class="s1">orient=</span><span class="s0">None,</span>
    <span class="s1">typ=</span><span class="s3">&quot;frame&quot;</span><span class="s0">,</span>
    <span class="s1">dtype: DtypeArg | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">convert_axes=</span><span class="s0">None,</span>
    <span class="s1">convert_dates=</span><span class="s0">True,</span>
    <span class="s1">keep_default_dates: bool = </span><span class="s0">True,</span>
    <span class="s1">numpy: bool = </span><span class="s0">False,</span>
    <span class="s1">precise_float: bool = </span><span class="s0">False,</span>
    <span class="s1">date_unit=</span><span class="s0">None,</span>
    <span class="s1">encoding=</span><span class="s0">None,</span>
    <span class="s1">encoding_errors: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s3">&quot;strict&quot;</span><span class="s0">,</span>
    <span class="s1">lines: bool = </span><span class="s0">False,</span>
    <span class="s1">chunksize: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">compression: CompressionOptions = </span><span class="s3">&quot;infer&quot;</span><span class="s0">,</span>
    <span class="s1">nrows: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">storage_options: StorageOptions = </span><span class="s0">None,</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Convert a JSON string to pandas object. 
 
    Parameters 
    ---------- 
    path_or_buf : a valid JSON str, path object or file-like object 
        Any valid string path is acceptable. The string could be a URL. Valid 
        URL schemes include http, ftp, s3, and file. For file URLs, a host is 
        expected. A local file could be: 
        ``file://localhost/path/to/table.json``. 
 
        If you want to pass in a path object, pandas accepts any 
        ``os.PathLike``. 
 
        By file-like object, we refer to objects with a ``read()`` method, 
        such as a file handle (e.g. via builtin ``open`` function) 
        or ``StringIO``. 
    orient : str 
        Indication of expected JSON string format. 
        Compatible JSON strings can be produced by ``to_json()`` with a 
        corresponding orient value. 
        The set of possible orients is: 
 
        - ``'split'`` : dict like 
          ``{{index -&gt; [index], columns -&gt; [columns], data -&gt; [values]}}`` 
        - ``'records'`` : list like 
          ``[{{column -&gt; value}}, ... , {{column -&gt; value}}]`` 
        - ``'index'`` : dict like ``{{index -&gt; {{column -&gt; value}}}}`` 
        - ``'columns'`` : dict like ``{{column -&gt; {{index -&gt; value}}}}`` 
        - ``'values'`` : just the values array 
 
        The allowed and default values depend on the value 
        of the `typ` parameter. 
 
        * when ``typ == 'series'``, 
 
          - allowed orients are ``{{'split','records','index'}}`` 
          - default is ``'index'`` 
          - The Series index must be unique for orient ``'index'``. 
 
        * when ``typ == 'frame'``, 
 
          - allowed orients are ``{{'split','records','index', 
            'columns','values', 'table'}}`` 
          - default is ``'columns'`` 
          - The DataFrame index must be unique for orients ``'index'`` and 
            ``'columns'``. 
          - The DataFrame columns must be unique for orients ``'index'``, 
            ``'columns'``, and ``'records'``. 
 
    typ : {{'frame', 'series'}}, default 'frame' 
        The type of object to recover. 
 
    dtype : bool or dict, default None 
        If True, infer dtypes; if a dict of column to dtype, then use those; 
        if False, then don't infer dtypes at all, applies only to the data. 
 
        For all ``orient`` values except ``'table'``, default is True. 
 
        .. versionchanged:: 0.25.0 
 
           Not applicable for ``orient='table'``. 
 
    convert_axes : bool, default None 
        Try to convert the axes to the proper dtypes. 
 
        For all ``orient`` values except ``'table'``, default is True. 
 
        .. versionchanged:: 0.25.0 
 
           Not applicable for ``orient='table'``. 
 
    convert_dates : bool or list of str, default True 
        If True then default datelike columns may be converted (depending on 
        keep_default_dates). 
        If False, no dates will be converted. 
        If a list of column names, then those columns will be converted and 
        default datelike columns may also be converted (depending on 
        keep_default_dates). 
 
    keep_default_dates : bool, default True 
        If parsing dates (convert_dates is not False), then try to parse the 
        default datelike columns. 
        A column label is datelike if 
 
        * it ends with ``'_at'``, 
 
        * it ends with ``'_time'``, 
 
        * it begins with ``'timestamp'``, 
 
        * it is ``'modified'``, or 
 
        * it is ``'date'``. 
 
    numpy : bool, default False 
        Direct decoding to numpy arrays. Supports numeric data only, but 
        non-numeric column and index labels are supported. Note also that the 
        JSON ordering MUST be the same for each term if numpy=True. 
 
        .. deprecated:: 1.0.0 
 
    precise_float : bool, default False 
        Set to enable usage of higher precision (strtod) function when 
        decoding string to double values. Default (False) is to use fast but 
        less precise builtin functionality. 
 
    date_unit : str, default None 
        The timestamp unit to detect if converting dates. The default behaviour 
        is to try and detect the correct precision, but if this is not desired 
        then pass one of 's', 'ms', 'us' or 'ns' to force parsing only seconds, 
        milliseconds, microseconds or nanoseconds respectively. 
 
    encoding : str, default is 'utf-8' 
        The encoding to use to decode py3 bytes. 
 
    encoding_errors : str, optional, default &quot;strict&quot; 
        How encoding errors are treated. `List of possible values 
        &lt;https://docs.python.org/3/library/codecs.html#error-handlers&gt;`_ . 
 
        .. versionadded:: 1.3.0 
 
    lines : bool, default False 
        Read the file as a json object per line. 
 
    chunksize : int, optional 
        Return JsonReader object for iteration. 
        See the `line-delimited json docs 
        &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#line-delimited-json&gt;`_ 
        for more information on ``chunksize``. 
        This can only be passed if `lines=True`. 
        If this is None, the file will be read into memory all at once. 
 
        .. versionchanged:: 1.2 
 
           ``JsonReader`` is a context manager. 
 
    {decompression_options} 
 
        .. versionchanged:: 1.4.0 Zstandard support. 
 
    nrows : int, optional 
        The number of lines from the line-delimited jsonfile that has to be read. 
        This can only be passed if `lines=True`. 
        If this is None, all the rows will be returned. 
 
        .. versionadded:: 1.1 
 
    {storage_options} 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    Series or DataFrame 
        The type returned depends on the value of `typ`. 
 
    See Also 
    -------- 
    DataFrame.to_json : Convert a DataFrame to a JSON string. 
    Series.to_json : Convert a Series to a JSON string. 
    json_normalize : Normalize semi-structured JSON data into a flat table. 
 
    Notes 
    ----- 
    Specific to ``orient='table'``, if a :class:`DataFrame` with a literal 
    :class:`Index` name of `index` gets written with :func:`to_json`, the 
    subsequent read operation will incorrectly set the :class:`Index` name to 
    ``None``. This is because `index` is also used by :func:`DataFrame.to_json` 
    to denote a missing :class:`Index` name, and the subsequent 
    :func:`read_json` operation cannot distinguish between the two. The same 
    limitation is encountered with a :class:`MultiIndex` and any names 
    beginning with ``'level_'``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; df = pd.DataFrame([['a', 'b'], ['c', 'd']], 
    ...                   index=['row 1', 'row 2'], 
    ...                   columns=['col 1', 'col 2']) 
 
    Encoding/decoding a Dataframe using ``'split'`` formatted JSON: 
 
    &gt;&gt;&gt; df.to_json(orient='split') 
        '\ 
{{\ 
&quot;columns&quot;:[&quot;col 1&quot;,&quot;col 2&quot;],\ 
&quot;index&quot;:[&quot;row 1&quot;,&quot;row 2&quot;],\ 
&quot;data&quot;:[[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]]\ 
}}\ 
' 
    &gt;&gt;&gt; pd.read_json(_, orient='split') 
          col 1 col 2 
    row 1     a     b 
    row 2     c     d 
 
    Encoding/decoding a Dataframe using ``'index'`` formatted JSON: 
 
    &gt;&gt;&gt; df.to_json(orient='index') 
    '{{&quot;row 1&quot;:{{&quot;col 1&quot;:&quot;a&quot;,&quot;col 2&quot;:&quot;b&quot;}},&quot;row 2&quot;:{{&quot;col 1&quot;:&quot;c&quot;,&quot;col 2&quot;:&quot;d&quot;}}}}' 
 
    &gt;&gt;&gt; pd.read_json(_, orient='index') 
          col 1 col 2 
    row 1     a     b 
    row 2     c     d 
 
    Encoding/decoding a Dataframe using ``'records'`` formatted JSON. 
    Note that index labels are not preserved with this encoding. 
 
    &gt;&gt;&gt; df.to_json(orient='records') 
    '[{{&quot;col 1&quot;:&quot;a&quot;,&quot;col 2&quot;:&quot;b&quot;}},{{&quot;col 1&quot;:&quot;c&quot;,&quot;col 2&quot;:&quot;d&quot;}}]' 
    &gt;&gt;&gt; pd.read_json(_, orient='records') 
      col 1 col 2 
    0     a     b 
    1     c     d 
 
    Encoding with Table Schema 
 
    &gt;&gt;&gt; df.to_json(orient='table') 
        '\ 
{{&quot;schema&quot;:{{&quot;fields&quot;:[\ 
{{&quot;name&quot;:&quot;index&quot;,&quot;type&quot;:&quot;string&quot;}},\ 
{{&quot;name&quot;:&quot;col 1&quot;,&quot;type&quot;:&quot;string&quot;}},\ 
{{&quot;name&quot;:&quot;col 2&quot;,&quot;type&quot;:&quot;string&quot;}}],\ 
&quot;primaryKey&quot;:[&quot;index&quot;],\ 
&quot;pandas_version&quot;:&quot;1.4.0&quot;}},\ 
&quot;data&quot;:[\ 
{{&quot;index&quot;:&quot;row 1&quot;,&quot;col 1&quot;:&quot;a&quot;,&quot;col 2&quot;:&quot;b&quot;}},\ 
{{&quot;index&quot;:&quot;row 2&quot;,&quot;col 1&quot;:&quot;c&quot;,&quot;col 2&quot;:&quot;d&quot;}}]\ 
}}\ 
' 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">orient == </span><span class="s3">&quot;table&quot; </span><span class="s0">and </span><span class="s1">dtype:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;cannot pass both dtype and orient='table'&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">orient == </span><span class="s3">&quot;table&quot; </span><span class="s0">and </span><span class="s1">convert_axes:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;cannot pass both convert_axes and orient='table'&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None and </span><span class="s1">orient != </span><span class="s3">&quot;table&quot;</span><span class="s1">:</span>
        <span class="s2"># error: Incompatible types in assignment (expression has type &quot;bool&quot;, variable</span>
        <span class="s2"># has type &quot;Union[ExtensionDtype, str, dtype[Any], Type[str], Type[float],</span>
        <span class="s2"># Type[int], Type[complex], Type[bool], Type[object], Dict[Hashable,</span>
        <span class="s2"># Union[ExtensionDtype, Union[str, dtype[Any]], Type[str], Type[float],</span>
        <span class="s2"># Type[int], Type[complex], Type[bool], Type[object]]], None]&quot;)</span>
        <span class="s1">dtype = </span><span class="s0">True  </span><span class="s2"># type: ignore[assignment]</span>
    <span class="s0">if </span><span class="s1">convert_axes </span><span class="s0">is None and </span><span class="s1">orient != </span><span class="s3">&quot;table&quot;</span><span class="s1">:</span>
        <span class="s1">convert_axes = </span><span class="s0">True</span>

    <span class="s1">json_reader = JsonReader(</span>
        <span class="s1">path_or_buf</span><span class="s0">,</span>
        <span class="s1">orient=orient</span><span class="s0">,</span>
        <span class="s1">typ=typ</span><span class="s0">,</span>
        <span class="s1">dtype=dtype</span><span class="s0">,</span>
        <span class="s1">convert_axes=convert_axes</span><span class="s0">,</span>
        <span class="s1">convert_dates=convert_dates</span><span class="s0">,</span>
        <span class="s1">keep_default_dates=keep_default_dates</span><span class="s0">,</span>
        <span class="s1">numpy=numpy</span><span class="s0">,</span>
        <span class="s1">precise_float=precise_float</span><span class="s0">,</span>
        <span class="s1">date_unit=date_unit</span><span class="s0">,</span>
        <span class="s1">encoding=encoding</span><span class="s0">,</span>
        <span class="s1">lines=lines</span><span class="s0">,</span>
        <span class="s1">chunksize=chunksize</span><span class="s0">,</span>
        <span class="s1">compression=compression</span><span class="s0">,</span>
        <span class="s1">nrows=nrows</span><span class="s0">,</span>
        <span class="s1">storage_options=storage_options</span><span class="s0">,</span>
        <span class="s1">encoding_errors=encoding_errors</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">chunksize:</span>
        <span class="s0">return </span><span class="s1">json_reader</span>

    <span class="s0">with </span><span class="s1">json_reader:</span>
        <span class="s0">return </span><span class="s1">json_reader.read()</span>


<span class="s0">class </span><span class="s1">JsonReader(abc.Iterator):</span>
    <span class="s5">&quot;&quot;&quot; 
    JsonReader provides an interface for reading in a JSON file. 
 
    If initialized with ``lines=True`` and ``chunksize``, can be iterated over 
    ``chunksize`` lines at a time. Otherwise, calling ``read`` reads in the 
    whole document. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">filepath_or_buffer</span><span class="s0">,</span>
        <span class="s1">orient</span><span class="s0">,</span>
        <span class="s1">typ</span><span class="s0">,</span>
        <span class="s1">dtype</span><span class="s0">,</span>
        <span class="s1">convert_axes</span><span class="s0">,</span>
        <span class="s1">convert_dates</span><span class="s0">,</span>
        <span class="s1">keep_default_dates: bool</span><span class="s0">,</span>
        <span class="s1">numpy: bool</span><span class="s0">,</span>
        <span class="s1">precise_float: bool</span><span class="s0">,</span>
        <span class="s1">date_unit</span><span class="s0">,</span>
        <span class="s1">encoding</span><span class="s0">,</span>
        <span class="s1">lines: bool</span><span class="s0">,</span>
        <span class="s1">chunksize: int | </span><span class="s0">None,</span>
        <span class="s1">compression: CompressionOptions</span><span class="s0">,</span>
        <span class="s1">nrows: int | </span><span class="s0">None,</span>
        <span class="s1">storage_options: StorageOptions = </span><span class="s0">None,</span>
        <span class="s1">encoding_errors: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s3">&quot;strict&quot;</span><span class="s0">,</span>
    <span class="s1">):</span>

        <span class="s1">self.orient = orient</span>
        <span class="s1">self.typ = typ</span>
        <span class="s1">self.dtype = dtype</span>
        <span class="s1">self.convert_axes = convert_axes</span>
        <span class="s1">self.convert_dates = convert_dates</span>
        <span class="s1">self.keep_default_dates = keep_default_dates</span>
        <span class="s1">self.numpy = numpy</span>
        <span class="s1">self.precise_float = precise_float</span>
        <span class="s1">self.date_unit = date_unit</span>
        <span class="s1">self.encoding = encoding</span>
        <span class="s1">self.compression = compression</span>
        <span class="s1">self.storage_options = storage_options</span>
        <span class="s1">self.lines = lines</span>
        <span class="s1">self.chunksize = chunksize</span>
        <span class="s1">self.nrows_seen = </span><span class="s4">0</span>
        <span class="s1">self.nrows = nrows</span>
        <span class="s1">self.encoding_errors = encoding_errors</span>
        <span class="s1">self.handles: IOHandles[str] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">self.chunksize </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.chunksize = validate_integer(</span><span class="s3">&quot;chunksize&quot;</span><span class="s0">, </span><span class="s1">self.chunksize</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">self.lines:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;chunksize can only be passed if lines=True&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.nrows </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.nrows = validate_integer(</span><span class="s3">&quot;nrows&quot;</span><span class="s0">, </span><span class="s1">self.nrows</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">self.lines:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;nrows can only be passed if lines=True&quot;</span><span class="s1">)</span>

        <span class="s1">data = self._get_data_from_filepath(filepath_or_buffer)</span>
        <span class="s1">self.data = self._preprocess_data(data)</span>

    <span class="s0">def </span><span class="s1">_preprocess_data(self</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s5">&quot;&quot;&quot; 
        At this point, the data either has a `read` attribute (e.g. a file 
        object or a StringIO) or is a string that is a JSON document. 
 
        If self.chunksize, we prepare the data for the `__next__` method. 
        Otherwise, we read it into memory for the `read` method. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">hasattr(data</span><span class="s0">, </span><span class="s3">&quot;read&quot;</span><span class="s1">) </span><span class="s0">and not </span><span class="s1">(self.chunksize </span><span class="s0">or </span><span class="s1">self.nrows):</span>
            <span class="s0">with </span><span class="s1">self:</span>
                <span class="s1">data = data.read()</span>
        <span class="s0">if not </span><span class="s1">hasattr(data</span><span class="s0">, </span><span class="s3">&quot;read&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(self.chunksize </span><span class="s0">or </span><span class="s1">self.nrows):</span>
            <span class="s1">data = StringIO(data)</span>

        <span class="s0">return </span><span class="s1">data</span>

    <span class="s0">def </span><span class="s1">_get_data_from_filepath(self</span><span class="s0">, </span><span class="s1">filepath_or_buffer):</span>
        <span class="s5">&quot;&quot;&quot; 
        The function read_json accepts three input types: 
            1. filepath (string-like) 
            2. file-like object (e.g. open file object, StringIO) 
            3. JSON string 
 
        This method turns (1) into (2) to simplify the rest of the processing. 
        It returns input types (2) and (3) unchanged. 
        &quot;&quot;&quot;</span>
        <span class="s2"># if it is a string but the file does not exist, it might be a JSON string</span>
        <span class="s1">filepath_or_buffer = stringify_path(filepath_or_buffer)</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s0">not </span><span class="s1">isinstance(filepath_or_buffer</span><span class="s0">, </span><span class="s1">str)</span>
            <span class="s0">or </span><span class="s1">is_url(filepath_or_buffer)</span>
            <span class="s0">or </span><span class="s1">is_fsspec_url(filepath_or_buffer)</span>
            <span class="s0">or </span><span class="s1">file_exists(filepath_or_buffer)</span>
        <span class="s1">):</span>
            <span class="s1">self.handles = get_handle(</span>
                <span class="s1">filepath_or_buffer</span><span class="s0">,</span>
                <span class="s3">&quot;r&quot;</span><span class="s0">,</span>
                <span class="s1">encoding=self.encoding</span><span class="s0">,</span>
                <span class="s1">compression=self.compression</span><span class="s0">,</span>
                <span class="s1">storage_options=self.storage_options</span><span class="s0">,</span>
                <span class="s1">errors=self.encoding_errors</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">filepath_or_buffer = self.handles.handle</span>

        <span class="s0">return </span><span class="s1">filepath_or_buffer</span>

    <span class="s0">def </span><span class="s1">_combine_lines(self</span><span class="s0">, </span><span class="s1">lines) -&gt; str:</span>
        <span class="s5">&quot;&quot;&quot; 
        Combines a list of JSON objects into one JSON object. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s3">f'[</span><span class="s0">{</span><span class="s3">&quot;,&quot;</span><span class="s1">.join([line </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">(line.strip() </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">lines) </span><span class="s0">if </span><span class="s1">line])</span><span class="s0">}</span><span class="s3">]'</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">read(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Read the whole JSON input into a pandas object. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.lines:</span>
            <span class="s0">if </span><span class="s1">self.chunksize:</span>
                <span class="s1">obj = concat(self)</span>
            <span class="s0">elif </span><span class="s1">self.nrows:</span>
                <span class="s1">lines = list(islice(self.data</span><span class="s0">, </span><span class="s1">self.nrows))</span>
                <span class="s1">lines_json = self._combine_lines(lines)</span>
                <span class="s1">obj = self._get_object_parser(lines_json)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">data = ensure_str(self.data)</span>
                <span class="s1">data_lines = data.split(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
                <span class="s1">obj = self._get_object_parser(self._combine_lines(data_lines))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">obj = self._get_object_parser(self.data)</span>
        <span class="s1">self.close()</span>
        <span class="s0">return </span><span class="s1">obj</span>

    <span class="s0">def </span><span class="s1">_get_object_parser(self</span><span class="s0">, </span><span class="s1">json):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parses a json document into a pandas object. 
        &quot;&quot;&quot;</span>
        <span class="s1">typ = self.typ</span>
        <span class="s1">dtype = self.dtype</span>
        <span class="s1">kwargs = {</span>
            <span class="s3">&quot;orient&quot;</span><span class="s1">: self.orient</span><span class="s0">,</span>
            <span class="s3">&quot;dtype&quot;</span><span class="s1">: self.dtype</span><span class="s0">,</span>
            <span class="s3">&quot;convert_axes&quot;</span><span class="s1">: self.convert_axes</span><span class="s0">,</span>
            <span class="s3">&quot;convert_dates&quot;</span><span class="s1">: self.convert_dates</span><span class="s0">,</span>
            <span class="s3">&quot;keep_default_dates&quot;</span><span class="s1">: self.keep_default_dates</span><span class="s0">,</span>
            <span class="s3">&quot;numpy&quot;</span><span class="s1">: self.numpy</span><span class="s0">,</span>
            <span class="s3">&quot;precise_float&quot;</span><span class="s1">: self.precise_float</span><span class="s0">,</span>
            <span class="s3">&quot;date_unit&quot;</span><span class="s1">: self.date_unit</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">obj = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">typ == </span><span class="s3">&quot;frame&quot;</span><span class="s1">:</span>
            <span class="s1">obj = FrameParser(json</span><span class="s0">, </span><span class="s1">**kwargs).parse()</span>

        <span class="s0">if </span><span class="s1">typ == </span><span class="s3">&quot;series&quot; </span><span class="s0">or </span><span class="s1">obj </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">bool):</span>
                <span class="s1">kwargs[</span><span class="s3">&quot;dtype&quot;</span><span class="s1">] = dtype</span>
            <span class="s1">obj = SeriesParser(json</span><span class="s0">, </span><span class="s1">**kwargs).parse()</span>

        <span class="s0">return </span><span class="s1">obj</span>

    <span class="s0">def </span><span class="s1">close(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        If we opened a stream earlier, in _get_data_from_filepath, we should 
        close it. 
 
        If an open stream or file was passed, we leave it open. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.handles </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.handles.close()</span>

    <span class="s0">def </span><span class="s1">__next__(self):</span>
        <span class="s0">if </span><span class="s1">self.nrows:</span>
            <span class="s0">if </span><span class="s1">self.nrows_seen &gt;= self.nrows:</span>
                <span class="s1">self.close()</span>
                <span class="s0">raise </span><span class="s1">StopIteration</span>

        <span class="s1">lines = list(islice(self.data</span><span class="s0">, </span><span class="s1">self.chunksize))</span>
        <span class="s0">if </span><span class="s1">lines:</span>
            <span class="s1">lines_json = self._combine_lines(lines)</span>
            <span class="s1">obj = self._get_object_parser(lines_json)</span>

            <span class="s2"># Make sure that the returned objects have the right index.</span>
            <span class="s1">obj.index = range(self.nrows_seen</span><span class="s0">, </span><span class="s1">self.nrows_seen + len(obj))</span>
            <span class="s1">self.nrows_seen += len(obj)</span>

            <span class="s0">return </span><span class="s1">obj</span>

        <span class="s1">self.close()</span>
        <span class="s0">raise </span><span class="s1">StopIteration</span>

    <span class="s0">def </span><span class="s1">__enter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(self</span><span class="s0">, </span><span class="s1">exc_type</span><span class="s0">, </span><span class="s1">exc_value</span><span class="s0">, </span><span class="s1">traceback):</span>
        <span class="s1">self.close()</span>


<span class="s0">class </span><span class="s1">Parser:</span>
    <span class="s1">_split_keys: tuple[str</span><span class="s0">, </span><span class="s1">...]</span>
    <span class="s1">_default_orient: str</span>

    <span class="s1">_STAMP_UNITS = (</span><span class="s3">&quot;s&quot;</span><span class="s0">, </span><span class="s3">&quot;ms&quot;</span><span class="s0">, </span><span class="s3">&quot;us&quot;</span><span class="s0">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
    <span class="s1">_MIN_STAMPS = {</span>
        <span class="s3">&quot;s&quot;</span><span class="s1">: </span><span class="s4">31536000</span><span class="s0">,</span>
        <span class="s3">&quot;ms&quot;</span><span class="s1">: </span><span class="s4">31536000000</span><span class="s0">,</span>
        <span class="s3">&quot;us&quot;</span><span class="s1">: </span><span class="s4">31536000000000</span><span class="s0">,</span>
        <span class="s3">&quot;ns&quot;</span><span class="s1">: </span><span class="s4">31536000000000000</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">json</span><span class="s0">,</span>
        <span class="s1">orient</span><span class="s0">,</span>
        <span class="s1">dtype: DtypeArg | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">convert_axes=</span><span class="s0">True,</span>
        <span class="s1">convert_dates=</span><span class="s0">True,</span>
        <span class="s1">keep_default_dates=</span><span class="s0">False,</span>
        <span class="s1">numpy=</span><span class="s0">False,</span>
        <span class="s1">precise_float=</span><span class="s0">False,</span>
        <span class="s1">date_unit=</span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.json = json</span>

        <span class="s0">if </span><span class="s1">orient </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">orient = self._default_orient</span>

        <span class="s1">self.orient = orient</span>

        <span class="s1">self.dtype = dtype</span>

        <span class="s0">if </span><span class="s1">orient == </span><span class="s3">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">numpy = </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">date_unit </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">date_unit = date_unit.lower()</span>
            <span class="s0">if </span><span class="s1">date_unit </span><span class="s0">not in </span><span class="s1">self._STAMP_UNITS:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;date_unit must be one of </span><span class="s0">{</span><span class="s1">self._STAMP_UNITS</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s1">self.min_stamp = self._MIN_STAMPS[date_unit]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.min_stamp = self._MIN_STAMPS[</span><span class="s3">&quot;s&quot;</span><span class="s1">]</span>

        <span class="s1">self.numpy = numpy</span>
        <span class="s1">self.precise_float = precise_float</span>
        <span class="s1">self.convert_axes = convert_axes</span>
        <span class="s1">self.convert_dates = convert_dates</span>
        <span class="s1">self.date_unit = date_unit</span>
        <span class="s1">self.keep_default_dates = keep_default_dates</span>
        <span class="s1">self.obj: DataFrame | Series | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">check_keys_split(self</span><span class="s0">, </span><span class="s1">decoded):</span>
        <span class="s5">&quot;&quot;&quot; 
        Checks that dict has only the appropriate keys for orient='split'. 
        &quot;&quot;&quot;</span>
        <span class="s1">bad_keys = set(decoded.keys()).difference(set(self._split_keys))</span>
        <span class="s0">if </span><span class="s1">bad_keys:</span>
            <span class="s1">bad_keys_joined = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(bad_keys)</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;JSON data had unexpected key(s): </span><span class="s0">{</span><span class="s1">bad_keys_joined</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">parse(self):</span>

        <span class="s0">if </span><span class="s1">self.numpy:</span>
            <span class="s1">self._parse_numpy()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._parse_no_numpy()</span>

        <span class="s0">if </span><span class="s1">self.obj </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s0">if </span><span class="s1">self.convert_axes:</span>
            <span class="s1">self._convert_axes()</span>
        <span class="s1">self._try_convert_types()</span>
        <span class="s0">return </span><span class="s1">self.obj</span>

    <span class="s0">def </span><span class="s1">_parse_numpy(self):</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError(self)</span>

    <span class="s0">def </span><span class="s1">_parse_no_numpy(self):</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError(self)</span>

    <span class="s0">def </span><span class="s1">_convert_axes(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Try to convert axes. 
        &quot;&quot;&quot;</span>
        <span class="s1">obj = self.obj</span>
        <span class="s0">assert </span><span class="s1">obj </span><span class="s0">is not None  </span><span class="s2"># for mypy</span>
        <span class="s0">for </span><span class="s1">axis_name </span><span class="s0">in </span><span class="s1">obj._AXIS_ORDERS:</span>
            <span class="s1">new_axis</span><span class="s0">, </span><span class="s1">result = self._try_convert_data(</span>
                <span class="s1">name=axis_name</span><span class="s0">,</span>
                <span class="s1">data=obj._get_axis(axis_name)</span><span class="s0">,</span>
                <span class="s1">use_dtypes=</span><span class="s0">False,</span>
                <span class="s1">convert_dates=</span><span class="s0">True,</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">result:</span>
                <span class="s1">setattr(self.obj</span><span class="s0">, </span><span class="s1">axis_name</span><span class="s0">, </span><span class="s1">new_axis)</span>

    <span class="s0">def </span><span class="s1">_try_convert_types(self):</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError(self)</span>

    <span class="s0">def </span><span class="s1">_try_convert_data(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">use_dtypes: bool = </span><span class="s0">True, </span><span class="s1">convert_dates: bool = </span><span class="s0">True</span>
    <span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Try to parse a ndarray like into a column by inferring dtype. 
        &quot;&quot;&quot;</span>
        <span class="s2"># don't try to coerce, unless a force conversion</span>
        <span class="s0">if </span><span class="s1">use_dtypes:</span>
            <span class="s0">if not </span><span class="s1">self.dtype:</span>
                <span class="s0">if </span><span class="s1">all(notna(data)):</span>
                    <span class="s0">return </span><span class="s1">data</span><span class="s0">, False</span>
                <span class="s0">return </span><span class="s1">data.fillna(np.nan)</span><span class="s0">, True</span>

            <span class="s2"># error: Non-overlapping identity check (left operand type:</span>
            <span class="s2"># &quot;Union[ExtensionDtype, str, dtype[Any], Type[object],</span>
            <span class="s2"># Dict[Hashable, Union[ExtensionDtype, Union[str, dtype[Any]],</span>
            <span class="s2"># Type[str], Type[float], Type[int], Type[complex], Type[bool],</span>
            <span class="s2"># Type[object]]]]&quot;, right operand type: &quot;Literal[True]&quot;)</span>
            <span class="s0">elif </span><span class="s1">self.dtype </span><span class="s0">is True</span><span class="s1">:  </span><span class="s2"># type: ignore[comparison-overlap]</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># dtype to force</span>
                <span class="s1">dtype = (</span>
                    <span class="s1">self.dtype.get(name) </span><span class="s0">if </span><span class="s1">isinstance(self.dtype</span><span class="s0">, </span><span class="s1">dict) </span><span class="s0">else </span><span class="s1">self.dtype</span>
                <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s0">return </span><span class="s1">data.astype(dtype)</span><span class="s0">, True</span>
                    <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
                        <span class="s0">return </span><span class="s1">data</span><span class="s0">, False</span>

        <span class="s0">if </span><span class="s1">convert_dates:</span>
            <span class="s1">new_data</span><span class="s0">, </span><span class="s1">result = self._try_convert_to_date(data)</span>
            <span class="s0">if </span><span class="s1">result:</span>
                <span class="s0">return </span><span class="s1">new_data</span><span class="s0">, True</span>

        <span class="s0">if </span><span class="s1">data.dtype == </span><span class="s3">&quot;object&quot;</span><span class="s1">:</span>

            <span class="s2"># try float</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">data = data.astype(</span><span class="s3">&quot;float64&quot;</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
                <span class="s0">pass</span>

        <span class="s0">if </span><span class="s1">data.dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>

            <span class="s0">if </span><span class="s1">data.dtype != </span><span class="s3">&quot;float64&quot;</span><span class="s1">:</span>

                <span class="s2"># coerce floats to 64</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">data = data.astype(</span><span class="s3">&quot;float64&quot;</span><span class="s1">)</span>
                <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
                    <span class="s0">pass</span>

        <span class="s2"># don't coerce 0-len data</span>
        <span class="s0">if </span><span class="s1">len(data) </span><span class="s0">and </span><span class="s1">(data.dtype == </span><span class="s3">&quot;float&quot; </span><span class="s0">or </span><span class="s1">data.dtype == </span><span class="s3">&quot;object&quot;</span><span class="s1">):</span>

            <span class="s2"># coerce ints if we can</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">new_data = data.astype(</span><span class="s3">&quot;int64&quot;</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">(new_data == data).all():</span>
                    <span class="s1">data = new_data</span>
            <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s1">OverflowError):</span>
                <span class="s0">pass</span>

        <span class="s2"># coerce ints to 64</span>
        <span class="s0">if </span><span class="s1">data.dtype == </span><span class="s3">&quot;int&quot;</span><span class="s1">:</span>

            <span class="s2"># coerce floats to 64</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">data = data.astype(</span><span class="s3">&quot;int64&quot;</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
                <span class="s0">pass</span>

        <span class="s2"># if we have an index, we want to preserve dtypes</span>
        <span class="s0">if </span><span class="s1">name == </span><span class="s3">&quot;index&quot; </span><span class="s0">and </span><span class="s1">len(data):</span>
            <span class="s0">if </span><span class="s1">self.orient == </span><span class="s3">&quot;split&quot;</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">data</span><span class="s0">, False</span>

        <span class="s0">return </span><span class="s1">data</span><span class="s0">, True</span>

    <span class="s0">def </span><span class="s1">_try_convert_to_date(self</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s5">&quot;&quot;&quot; 
        Try to parse a ndarray like into a date column. 
 
        Try to coerce object in epoch/iso formats and integer/float in epoch 
        formats. Return a boolean if parsing was successful. 
        &quot;&quot;&quot;</span>
        <span class="s2"># no conversion on empty</span>
        <span class="s0">if not </span><span class="s1">len(data):</span>
            <span class="s0">return </span><span class="s1">data</span><span class="s0">, False</span>

        <span class="s1">new_data = data</span>
        <span class="s0">if </span><span class="s1">new_data.dtype == </span><span class="s3">&quot;object&quot;</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">new_data = data.astype(</span><span class="s3">&quot;int64&quot;</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s1">OverflowError):</span>
                <span class="s0">pass</span>

        <span class="s2"># ignore numbers that are out of range</span>
        <span class="s0">if </span><span class="s1">issubclass(new_data.dtype.type</span><span class="s0">, </span><span class="s1">np.number):</span>
            <span class="s1">in_range = (</span>
                <span class="s1">isna(new_data._values)</span>
                <span class="s1">| (new_data &gt; self.min_stamp)</span>
                <span class="s1">| (new_data._values == iNaT)</span>
            <span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">in_range.all():</span>
                <span class="s0">return </span><span class="s1">data</span><span class="s0">, False</span>

        <span class="s1">date_units = (self.date_unit</span><span class="s0">,</span><span class="s1">) </span><span class="s0">if </span><span class="s1">self.date_unit </span><span class="s0">else </span><span class="s1">self._STAMP_UNITS</span>
        <span class="s0">for </span><span class="s1">date_unit </span><span class="s0">in </span><span class="s1">date_units:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">new_data = to_datetime(new_data</span><span class="s0">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s0">, </span><span class="s1">unit=date_unit)</span>
            <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">OverflowError</span><span class="s0">, </span><span class="s1">TypeError):</span>
                <span class="s0">continue</span>
            <span class="s0">return </span><span class="s1">new_data</span><span class="s0">, True</span>
        <span class="s0">return </span><span class="s1">data</span><span class="s0">, False</span>

    <span class="s0">def </span><span class="s1">_try_convert_dates(self):</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError(self)</span>


<span class="s0">class </span><span class="s1">SeriesParser(Parser):</span>
    <span class="s1">_default_orient = </span><span class="s3">&quot;index&quot;</span>
    <span class="s1">_split_keys = (</span><span class="s3">&quot;name&quot;</span><span class="s0">, </span><span class="s3">&quot;index&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_parse_no_numpy(self):</span>
        <span class="s1">data = loads(self.json</span><span class="s0">, </span><span class="s1">precise_float=self.precise_float)</span>

        <span class="s0">if </span><span class="s1">self.orient == </span><span class="s3">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">decoded = {str(k): v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">data.items()}</span>
            <span class="s1">self.check_keys_split(decoded)</span>
            <span class="s1">self.obj = create_series_with_explicit_dtype(**decoded)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.obj = create_series_with_explicit_dtype(data</span><span class="s0">, </span><span class="s1">dtype_if_empty=object)</span>

    <span class="s0">def </span><span class="s1">_parse_numpy(self):</span>
        <span class="s1">load_kwargs = {</span>
            <span class="s3">&quot;dtype&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s3">&quot;numpy&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s3">&quot;precise_float&quot;</span><span class="s1">: self.precise_float</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">self.orient </span><span class="s0">in </span><span class="s1">[</span><span class="s3">&quot;columns&quot;</span><span class="s0">, </span><span class="s3">&quot;index&quot;</span><span class="s1">]:</span>
            <span class="s1">load_kwargs[</span><span class="s3">&quot;labelled&quot;</span><span class="s1">] = </span><span class="s0">True</span>
        <span class="s1">loads_ = functools.partial(loads</span><span class="s0">, </span><span class="s1">**load_kwargs)</span>
        <span class="s1">data = loads_(self.json)</span>

        <span class="s0">if </span><span class="s1">self.orient == </span><span class="s3">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">decoded = {str(k): v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">data.items()}</span>
            <span class="s1">self.check_keys_split(decoded)</span>
            <span class="s1">self.obj = create_series_with_explicit_dtype(**decoded)</span>
        <span class="s0">elif </span><span class="s1">self.orient </span><span class="s0">in </span><span class="s1">[</span><span class="s3">&quot;columns&quot;</span><span class="s0">, </span><span class="s3">&quot;index&quot;</span><span class="s1">]:</span>
            <span class="s2"># error: &quot;create_series_with_explicit_dtype&quot;</span>
            <span class="s2">#  gets multiple values for keyword argument &quot;dtype_if_empty</span>
            <span class="s1">self.obj = create_series_with_explicit_dtype(</span>
                <span class="s1">*data</span><span class="s0">, </span><span class="s1">dtype_if_empty=object</span>
            <span class="s1">)  </span><span class="s2"># type:ignore[misc]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.obj = create_series_with_explicit_dtype(data</span><span class="s0">, </span><span class="s1">dtype_if_empty=object)</span>

    <span class="s0">def </span><span class="s1">_try_convert_types(self):</span>
        <span class="s0">if </span><span class="s1">self.obj </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>
        <span class="s1">obj</span><span class="s0">, </span><span class="s1">result = self._try_convert_data(</span>
            <span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s1">self.obj</span><span class="s0">, </span><span class="s1">convert_dates=self.convert_dates</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">result:</span>
            <span class="s1">self.obj = obj</span>


<span class="s0">class </span><span class="s1">FrameParser(Parser):</span>
    <span class="s1">_default_orient = </span><span class="s3">&quot;columns&quot;</span>
    <span class="s1">_split_keys = (</span><span class="s3">&quot;columns&quot;</span><span class="s0">, </span><span class="s3">&quot;index&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_parse_numpy(self):</span>

        <span class="s1">json = self.json</span>
        <span class="s1">orient = self.orient</span>

        <span class="s0">if </span><span class="s1">orient == </span><span class="s3">&quot;columns&quot;</span><span class="s1">:</span>
            <span class="s1">args = loads(</span>
                <span class="s1">json</span><span class="s0">,</span>
                <span class="s1">dtype=</span><span class="s0">None,</span>
                <span class="s1">numpy=</span><span class="s0">True,</span>
                <span class="s1">labelled=</span><span class="s0">True,</span>
                <span class="s1">precise_float=self.precise_float</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">len(args):</span>
                <span class="s1">args = (args[</span><span class="s4">0</span><span class="s1">].T</span><span class="s0">, </span><span class="s1">args[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">self.obj = DataFrame(*args)</span>
        <span class="s0">elif </span><span class="s1">orient == </span><span class="s3">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">decoded = loads(</span>
                <span class="s1">json</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">numpy=</span><span class="s0">True, </span><span class="s1">precise_float=self.precise_float</span>
            <span class="s1">)</span>
            <span class="s1">decoded = {str(k): v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">decoded.items()}</span>
            <span class="s1">self.check_keys_split(decoded)</span>
            <span class="s1">self.obj = DataFrame(**decoded)</span>
        <span class="s0">elif </span><span class="s1">orient == </span><span class="s3">&quot;values&quot;</span><span class="s1">:</span>
            <span class="s1">self.obj = DataFrame(</span>
                <span class="s1">loads(json</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">numpy=</span><span class="s0">True, </span><span class="s1">precise_float=self.precise_float)</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.obj = DataFrame(</span>
                <span class="s1">*loads(</span>
                    <span class="s1">json</span><span class="s0">,</span>
                    <span class="s1">dtype=</span><span class="s0">None,</span>
                    <span class="s1">numpy=</span><span class="s0">True,</span>
                    <span class="s1">labelled=</span><span class="s0">True,</span>
                    <span class="s1">precise_float=self.precise_float</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_parse_no_numpy(self):</span>

        <span class="s1">json = self.json</span>
        <span class="s1">orient = self.orient</span>

        <span class="s0">if </span><span class="s1">orient == </span><span class="s3">&quot;columns&quot;</span><span class="s1">:</span>
            <span class="s1">self.obj = DataFrame(</span>
                <span class="s1">loads(json</span><span class="s0">, </span><span class="s1">precise_float=self.precise_float)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">orient == </span><span class="s3">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">decoded = {</span>
                <span class="s1">str(k): v</span>
                <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">loads(json</span><span class="s0">, </span><span class="s1">precise_float=self.precise_float).items()</span>
            <span class="s1">}</span>
            <span class="s1">self.check_keys_split(decoded)</span>
            <span class="s1">self.obj = DataFrame(dtype=</span><span class="s0">None, </span><span class="s1">**decoded)</span>
        <span class="s0">elif </span><span class="s1">orient == </span><span class="s3">&quot;index&quot;</span><span class="s1">:</span>
            <span class="s1">self.obj = DataFrame.from_dict(</span>
                <span class="s1">loads(json</span><span class="s0">, </span><span class="s1">precise_float=self.precise_float)</span><span class="s0">,</span>
                <span class="s1">dtype=</span><span class="s0">None,</span>
                <span class="s1">orient=</span><span class="s3">&quot;index&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">orient == </span><span class="s3">&quot;table&quot;</span><span class="s1">:</span>
            <span class="s1">self.obj = parse_table_schema(json</span><span class="s0">, </span><span class="s1">precise_float=self.precise_float)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.obj = DataFrame(</span>
                <span class="s1">loads(json</span><span class="s0">, </span><span class="s1">precise_float=self.precise_float)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_process_converter(self</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">filt=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Take a conversion function and possibly recreate the frame. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">filt </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">filt = </span><span class="s0">lambda </span><span class="s1">col</span><span class="s0">, </span><span class="s1">c: </span><span class="s0">True</span>

        <span class="s1">obj = self.obj</span>
        <span class="s0">assert </span><span class="s1">obj </span><span class="s0">is not None  </span><span class="s2"># for mypy</span>

        <span class="s1">needs_new_obj = </span><span class="s0">False</span>
        <span class="s1">new_obj = {}</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(col</span><span class="s0">, </span><span class="s1">c) </span><span class="s0">in </span><span class="s1">enumerate(obj.items()):</span>
            <span class="s0">if </span><span class="s1">filt(col</span><span class="s0">, </span><span class="s1">c):</span>
                <span class="s1">new_data</span><span class="s0">, </span><span class="s1">result = f(col</span><span class="s0">, </span><span class="s1">c)</span>
                <span class="s0">if </span><span class="s1">result:</span>
                    <span class="s1">c = new_data</span>
                    <span class="s1">needs_new_obj = </span><span class="s0">True</span>
            <span class="s1">new_obj[i] = c</span>

        <span class="s0">if </span><span class="s1">needs_new_obj:</span>

            <span class="s2"># possibly handle dup columns</span>
            <span class="s1">new_frame = DataFrame(new_obj</span><span class="s0">, </span><span class="s1">index=obj.index)</span>
            <span class="s1">new_frame.columns = obj.columns</span>
            <span class="s1">self.obj = new_frame</span>

    <span class="s0">def </span><span class="s1">_try_convert_types(self):</span>
        <span class="s0">if </span><span class="s1">self.obj </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">self.convert_dates:</span>
            <span class="s1">self._try_convert_dates()</span>

        <span class="s1">self._process_converter(</span>
            <span class="s0">lambda </span><span class="s1">col</span><span class="s0">, </span><span class="s1">c: self._try_convert_data(col</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">convert_dates=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_try_convert_dates(self):</span>
        <span class="s0">if </span><span class="s1">self.obj </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s2"># our columns to parse</span>
        <span class="s1">convert_dates = self.convert_dates</span>
        <span class="s0">if </span><span class="s1">convert_dates </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s1">convert_dates = []</span>
        <span class="s1">convert_dates = set(convert_dates)</span>

        <span class="s0">def </span><span class="s1">is_ok(col) -&gt; bool:</span>
            <span class="s5">&quot;&quot;&quot; 
            Return if this col is ok to try for a date parse. 
            &quot;&quot;&quot;</span>
            <span class="s0">if not </span><span class="s1">isinstance(col</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">return False</span>

            <span class="s1">col_lower = col.lower()</span>
            <span class="s0">if </span><span class="s1">(</span>
                <span class="s1">col_lower.endswith(</span><span class="s3">&quot;_at&quot;</span><span class="s1">)</span>
                <span class="s0">or </span><span class="s1">col_lower.endswith(</span><span class="s3">&quot;_time&quot;</span><span class="s1">)</span>
                <span class="s0">or </span><span class="s1">col_lower == </span><span class="s3">&quot;modified&quot;</span>
                <span class="s0">or </span><span class="s1">col_lower == </span><span class="s3">&quot;date&quot;</span>
                <span class="s0">or </span><span class="s1">col_lower == </span><span class="s3">&quot;datetime&quot;</span>
                <span class="s0">or </span><span class="s1">col_lower.startswith(</span><span class="s3">&quot;timestamp&quot;</span><span class="s1">)</span>
            <span class="s1">):</span>
                <span class="s0">return True</span>
            <span class="s0">return False</span>

        <span class="s1">self._process_converter(</span>
            <span class="s0">lambda </span><span class="s1">col</span><span class="s0">, </span><span class="s1">c: self._try_convert_to_date(c)</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">col</span><span class="s0">, </span><span class="s1">c: (</span>
                <span class="s1">(self.keep_default_dates </span><span class="s0">and </span><span class="s1">is_ok(col)) </span><span class="s0">or </span><span class="s1">col </span><span class="s0">in </span><span class="s1">convert_dates</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>
</pre>
</body>
</html>