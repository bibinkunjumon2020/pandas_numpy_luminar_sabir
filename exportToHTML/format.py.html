<html>
<head>
<title>format.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
format.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Internal module for formatting output data in csv, html, xml, 
and latex files. This module also applies to display formatting. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span>
<span class="s2">from </span><span class="s1">csv </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">QUOTE_NONE</span><span class="s2">,</span>
    <span class="s1">QUOTE_NONNUMERIC</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">decimal</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">StringIO</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">shutil </span><span class="s2">import </span><span class="s1">get_terminal_size</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">IO</span><span class="s2">,</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Hashable</span><span class="s2">,</span>
    <span class="s1">Iterable</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">Mapping</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">unicodedata </span><span class="s2">import </span><span class="s1">east_asian_width</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas._config.config </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">get_option</span><span class="s2">,</span>
    <span class="s1">set_option</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas._libs </span><span class="s2">import </span><span class="s1">lib</span>
<span class="s2">from </span><span class="s1">pandas._libs.missing </span><span class="s2">import </span><span class="s1">NA</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">Timedelta</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">iNaT</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs.nattype </span><span class="s2">import </span><span class="s1">NaTType</span>
<span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ArrayLike</span><span class="s2">,</span>
    <span class="s1">ColspaceArgType</span><span class="s2">,</span>
    <span class="s1">ColspaceType</span><span class="s2">,</span>
    <span class="s1">CompressionOptions</span><span class="s2">,</span>
    <span class="s1">FilePath</span><span class="s2">,</span>
    <span class="s1">FloatFormatType</span><span class="s2">,</span>
    <span class="s1">FormattersType</span><span class="s2">,</span>
    <span class="s1">IndexLabel</span><span class="s2">,</span>
    <span class="s1">StorageOptions</span><span class="s2">,</span>
    <span class="s1">WriteBuffer</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">is_categorical_dtype</span><span class="s2">,</span>
    <span class="s1">is_complex_dtype</span><span class="s2">,</span>
    <span class="s1">is_datetime64_dtype</span><span class="s2">,</span>
    <span class="s1">is_datetime64tz_dtype</span><span class="s2">,</span>
    <span class="s1">is_extension_array_dtype</span><span class="s2">,</span>
    <span class="s1">is_float</span><span class="s2">,</span>
    <span class="s1">is_float_dtype</span><span class="s2">,</span>
    <span class="s1">is_integer</span><span class="s2">,</span>
    <span class="s1">is_integer_dtype</span><span class="s2">,</span>
    <span class="s1">is_list_like</span><span class="s2">,</span>
    <span class="s1">is_numeric_dtype</span><span class="s2">,</span>
    <span class="s1">is_scalar</span><span class="s2">,</span>
    <span class="s1">is_timedelta64_dtype</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">isna</span><span class="s2">,</span>
    <span class="s1">notna</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Categorical</span><span class="s2">,</span>
    <span class="s1">DatetimeArray</span><span class="s2">,</span>
    <span class="s1">TimedeltaArray</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.base </span><span class="s2">import </span><span class="s1">PandasObject</span>
<span class="s2">import </span><span class="s1">pandas.core.common </span><span class="s2">as </span><span class="s1">com</span>
<span class="s2">from </span><span class="s1">pandas.core.construction </span><span class="s2">import </span><span class="s1">extract_array</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.api </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">MultiIndex</span><span class="s2">,</span>
    <span class="s1">PeriodIndex</span><span class="s2">,</span>
    <span class="s1">ensure_index</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.datetimes </span><span class="s2">import </span><span class="s1">DatetimeIndex</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.timedeltas </span><span class="s2">import </span><span class="s1">TimedeltaIndex</span>
<span class="s2">from </span><span class="s1">pandas.core.reshape.concat </span><span class="s2">import </span><span class="s1">concat</span>

<span class="s2">from </span><span class="s1">pandas.io.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">check_parent_directory</span><span class="s2">,</span>
    <span class="s1">stringify_path</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.io.formats.printing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">adjoin</span><span class="s2">,</span>
    <span class="s1">justify</span><span class="s2">,</span>
    <span class="s1">pprint_thing</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">DataFrame</span><span class="s2">,</span>
        <span class="s1">Series</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s1">common_docstring = </span><span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        buf : str, Path or StringIO-like, optional, default None 
            Buffer to write to. If None, the output is returned as a string. 
        columns : sequence, optional, default None 
            The subset of columns to write. Writes all columns by default. 
        col_space : %(col_space_type)s, optional 
            %(col_space)s. 
        header : %(header_type)s, optional 
            %(header)s. 
        index : bool, optional, default True 
            Whether to print index (row) labels. 
        na_rep : str, optional, default 'NaN' 
            String representation of ``NaN`` to use. 
        formatters : list, tuple or dict of one-param. functions, optional 
            Formatter functions to apply to columns' elements by position or 
            name. 
            The result of each function must be a unicode string. 
            List/tuple must be of length equal to the number of columns. 
        float_format : one-parameter function, optional, default None 
            Formatter function to apply to columns' elements if they are 
            floats. This function must return a unicode string and will be 
            applied only to the non-``NaN`` elements, with ``NaN`` being 
            handled by ``na_rep``. 
 
            .. versionchanged:: 1.2.0 
 
        sparsify : bool, optional, default True 
            Set to False for a DataFrame with a hierarchical index to print 
            every multiindex key at each row. 
        index_names : bool, optional, default True 
            Prints the names of the indexes. 
        justify : str, default None 
            How to justify the column labels. If None uses the option from 
            the print configuration (controlled by set_option), 'right' out 
            of the box. Valid values are 
 
            * left 
            * right 
            * center 
            * justify 
            * justify-all 
            * start 
            * end 
            * inherit 
            * match-parent 
            * initial 
            * unset. 
        max_rows : int, optional 
            Maximum number of rows to display in the console. 
        max_cols : int, optional 
            Maximum number of columns to display in the console. 
        show_dimensions : bool, default False 
            Display DataFrame dimensions (number of rows by number of columns). 
        decimal : str, default '.' 
            Character recognized as decimal separator, e.g. ',' in Europe. 
    &quot;&quot;&quot;</span>

<span class="s1">_VALID_JUSTIFY_PARAMETERS = (</span>
    <span class="s3">&quot;left&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;right&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;center&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;justify&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;justify-all&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;start&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;end&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;inherit&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;match-parent&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;initial&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;unset&quot;</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s1">return_docstring = </span><span class="s3">&quot;&quot;&quot; 
        Returns 
        ------- 
        str or None 
            If buf is None, returns the result as a string. Otherwise returns 
            None. 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">CategoricalFormatter:</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">categorical: Categorical</span><span class="s2">,</span>
        <span class="s1">buf: IO[str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">length: bool = </span><span class="s2">True,</span>
        <span class="s1">na_rep: str = </span><span class="s3">&quot;NaN&quot;</span><span class="s2">,</span>
        <span class="s1">footer: bool = </span><span class="s2">True,</span>
    <span class="s1">):</span>
        <span class="s1">self.categorical = categorical</span>
        <span class="s1">self.buf = buf </span><span class="s2">if </span><span class="s1">buf </span><span class="s2">is not None else </span><span class="s1">StringIO(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">self.na_rep = na_rep</span>
        <span class="s1">self.length = length</span>
        <span class="s1">self.footer = footer</span>
        <span class="s1">self.quoting = QUOTE_NONNUMERIC</span>

    <span class="s2">def </span><span class="s1">_get_footer(self) -&gt; str:</span>
        <span class="s1">footer = </span><span class="s3">&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.length:</span>
            <span class="s2">if </span><span class="s1">footer:</span>
                <span class="s1">footer += </span><span class="s3">&quot;, &quot;</span>
            <span class="s1">footer += </span><span class="s3">f&quot;Length: </span><span class="s2">{</span><span class="s1">len(self.categorical)</span><span class="s2">}</span><span class="s3">&quot;</span>

        <span class="s1">level_info = self.categorical._repr_categories_info()</span>

        <span class="s4"># Levels are added in a newline</span>
        <span class="s2">if </span><span class="s1">footer:</span>
            <span class="s1">footer += </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
        <span class="s1">footer += level_info</span>

        <span class="s2">return </span><span class="s1">str(footer)</span>

    <span class="s2">def </span><span class="s1">_get_formatted_values(self) -&gt; list[str]:</span>
        <span class="s2">return </span><span class="s1">format_array(</span>
            <span class="s1">self.categorical._internal_get_values()</span><span class="s2">,</span>
            <span class="s2">None,</span>
            <span class="s1">float_format=</span><span class="s2">None,</span>
            <span class="s1">na_rep=self.na_rep</span><span class="s2">,</span>
            <span class="s1">quoting=self.quoting</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">to_string(self) -&gt; str:</span>
        <span class="s1">categorical = self.categorical</span>

        <span class="s2">if </span><span class="s1">len(categorical) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.footer:</span>
                <span class="s2">return </span><span class="s1">self._get_footer()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s3">&quot;&quot;</span>

        <span class="s1">fmt_values = self._get_formatted_values()</span>

        <span class="s1">fmt_values = [i.strip() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">fmt_values]</span>
        <span class="s1">values = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(fmt_values)</span>
        <span class="s1">result = [</span><span class="s3">&quot;[&quot; </span><span class="s1">+ values + </span><span class="s3">&quot;]&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.footer:</span>
            <span class="s1">footer = self._get_footer()</span>
            <span class="s2">if </span><span class="s1">footer:</span>
                <span class="s1">result.append(footer)</span>

        <span class="s2">return </span><span class="s1">str(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(result))</span>


<span class="s2">class </span><span class="s1">SeriesFormatter:</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">series: Series</span><span class="s2">,</span>
        <span class="s1">buf: IO[str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">length: bool | str = </span><span class="s2">True,</span>
        <span class="s1">header: bool = </span><span class="s2">True,</span>
        <span class="s1">index: bool = </span><span class="s2">True,</span>
        <span class="s1">na_rep: str = </span><span class="s3">&quot;NaN&quot;</span><span class="s2">,</span>
        <span class="s1">name: bool = </span><span class="s2">False,</span>
        <span class="s1">float_format: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">dtype: bool = </span><span class="s2">True,</span>
        <span class="s1">max_rows: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">min_rows: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.series = series</span>
        <span class="s1">self.buf = buf </span><span class="s2">if </span><span class="s1">buf </span><span class="s2">is not None else </span><span class="s1">StringIO()</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.na_rep = na_rep</span>
        <span class="s1">self.header = header</span>
        <span class="s1">self.length = length</span>
        <span class="s1">self.index = index</span>
        <span class="s1">self.max_rows = max_rows</span>
        <span class="s1">self.min_rows = min_rows</span>

        <span class="s2">if </span><span class="s1">float_format </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">float_format = get_option(</span><span class="s3">&quot;display.float_format&quot;</span><span class="s1">)</span>
        <span class="s1">self.float_format = float_format</span>
        <span class="s1">self.dtype = dtype</span>
        <span class="s1">self.adj = get_adjustment()</span>

        <span class="s1">self._chk_truncate()</span>

    <span class="s2">def </span><span class="s1">_chk_truncate(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.tr_row_num: int | </span><span class="s2">None</span>

        <span class="s1">min_rows = self.min_rows</span>
        <span class="s1">max_rows = self.max_rows</span>
        <span class="s4"># truncation determined by max_rows, actual truncated number of rows</span>
        <span class="s4"># used below by min_rows</span>
        <span class="s1">is_truncated_vertically = max_rows </span><span class="s2">and </span><span class="s1">(len(self.series) &gt; max_rows)</span>
        <span class="s1">series = self.series</span>
        <span class="s2">if </span><span class="s1">is_truncated_vertically:</span>
            <span class="s1">max_rows = cast(int</span><span class="s2">, </span><span class="s1">max_rows)</span>
            <span class="s2">if </span><span class="s1">min_rows:</span>
                <span class="s4"># if min_rows is set (not None or 0), set max_rows to minimum</span>
                <span class="s4"># of both</span>
                <span class="s1">max_rows = min(min_rows</span><span class="s2">, </span><span class="s1">max_rows)</span>
            <span class="s2">if </span><span class="s1">max_rows == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">row_num = max_rows</span>
                <span class="s1">series = series.iloc[:max_rows]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">row_num = max_rows // </span><span class="s5">2</span>
                <span class="s1">series = concat((series.iloc[:row_num]</span><span class="s2">, </span><span class="s1">series.iloc[-row_num:]))</span>
            <span class="s1">self.tr_row_num = row_num</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.tr_row_num = </span><span class="s2">None</span>
        <span class="s1">self.tr_series = series</span>
        <span class="s1">self.is_truncated_vertically = is_truncated_vertically</span>

    <span class="s2">def </span><span class="s1">_get_footer(self) -&gt; str:</span>
        <span class="s1">name = self.series.name</span>
        <span class="s1">footer = </span><span class="s3">&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">getattr(self.series.index</span><span class="s2">, </span><span class="s3">&quot;freq&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">isinstance(</span>
                <span class="s1">self.series.index</span><span class="s2">, </span><span class="s1">(DatetimeIndex</span><span class="s2">, </span><span class="s1">PeriodIndex</span><span class="s2">, </span><span class="s1">TimedeltaIndex)</span>
            <span class="s1">)</span>
            <span class="s1">footer += </span><span class="s3">f&quot;Freq: </span><span class="s2">{</span><span class="s1">self.series.index.freqstr</span><span class="s2">}</span><span class="s3">&quot;</span>

        <span class="s2">if </span><span class="s1">self.name </span><span class="s2">is not False and </span><span class="s1">name </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">footer:</span>
                <span class="s1">footer += </span><span class="s3">&quot;, &quot;</span>

            <span class="s1">series_name = pprint_thing(name</span><span class="s2">, </span><span class="s1">escape_chars=(</span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\r</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">))</span>
            <span class="s1">footer += </span><span class="s3">f&quot;Name: </span><span class="s2">{</span><span class="s1">series_name</span><span class="s2">}</span><span class="s3">&quot;</span>

        <span class="s2">if </span><span class="s1">self.length </span><span class="s2">is True or </span><span class="s1">(</span>
            <span class="s1">self.length == </span><span class="s3">&quot;truncate&quot; </span><span class="s2">and </span><span class="s1">self.is_truncated_vertically</span>
        <span class="s1">):</span>
            <span class="s2">if </span><span class="s1">footer:</span>
                <span class="s1">footer += </span><span class="s3">&quot;, &quot;</span>
            <span class="s1">footer += </span><span class="s3">f&quot;Length: </span><span class="s2">{</span><span class="s1">len(self.series)</span><span class="s2">}</span><span class="s3">&quot;</span>

        <span class="s2">if </span><span class="s1">self.dtype </span><span class="s2">is not False and </span><span class="s1">self.dtype </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">dtype_name = getattr(self.tr_series.dtype</span><span class="s2">, </span><span class="s3">&quot;name&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">dtype_name:</span>
                <span class="s2">if </span><span class="s1">footer:</span>
                    <span class="s1">footer += </span><span class="s3">&quot;, &quot;</span>
                <span class="s1">footer += </span><span class="s3">f&quot;dtype: </span><span class="s2">{</span><span class="s1">pprint_thing(dtype_name)</span><span class="s2">}</span><span class="s3">&quot;</span>

        <span class="s4"># level infos are added to the end and in a new line, like it is done</span>
        <span class="s4"># for Categoricals</span>
        <span class="s2">if </span><span class="s1">is_categorical_dtype(self.tr_series.dtype):</span>
            <span class="s1">level_info = self.tr_series._values._repr_categories_info()</span>
            <span class="s2">if </span><span class="s1">footer:</span>
                <span class="s1">footer += </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s1">footer += level_info</span>

        <span class="s2">return </span><span class="s1">str(footer)</span>

    <span class="s2">def </span><span class="s1">_get_formatted_index(self) -&gt; tuple[list[str]</span><span class="s2">, </span><span class="s1">bool]:</span>
        <span class="s1">index = self.tr_series.index</span>

        <span class="s2">if </span><span class="s1">isinstance(index</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">have_header = any(name </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">index.names)</span>
            <span class="s1">fmt_index = index.format(names=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">have_header = index.name </span><span class="s2">is not None</span>
            <span class="s1">fmt_index = index.format(name=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">fmt_index</span><span class="s2">, </span><span class="s1">have_header</span>

    <span class="s2">def </span><span class="s1">_get_formatted_values(self) -&gt; list[str]:</span>
        <span class="s2">return </span><span class="s1">format_array(</span>
            <span class="s1">self.tr_series._values</span><span class="s2">,</span>
            <span class="s2">None,</span>
            <span class="s1">float_format=self.float_format</span><span class="s2">,</span>
            <span class="s1">na_rep=self.na_rep</span><span class="s2">,</span>
            <span class="s1">leading_space=self.index</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">to_string(self) -&gt; str:</span>
        <span class="s1">series = self.tr_series</span>
        <span class="s1">footer = self._get_footer()</span>

        <span class="s2">if </span><span class="s1">len(series) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self.series).__name__</span><span class="s2">}</span><span class="s3">([], </span><span class="s2">{</span><span class="s1">footer</span><span class="s2">}</span><span class="s3">)&quot;</span>

        <span class="s1">fmt_index</span><span class="s2">, </span><span class="s1">have_header = self._get_formatted_index()</span>
        <span class="s1">fmt_values = self._get_formatted_values()</span>

        <span class="s2">if </span><span class="s1">self.is_truncated_vertically:</span>
            <span class="s1">n_header_rows = </span><span class="s5">0</span>
            <span class="s1">row_num = self.tr_row_num</span>
            <span class="s1">row_num = cast(int</span><span class="s2">, </span><span class="s1">row_num)</span>
            <span class="s1">width = self.adj.len(fmt_values[row_num - </span><span class="s5">1</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">width &gt; </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s1">dot_str = </span><span class="s3">&quot;...&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">dot_str = </span><span class="s3">&quot;..&quot;</span>
            <span class="s4"># Series uses mode=center because it has single value columns</span>
            <span class="s4"># DataFrame uses mode=left</span>
            <span class="s1">dot_str = self.adj.justify([dot_str]</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;center&quot;</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">fmt_values.insert(row_num + n_header_rows</span><span class="s2">, </span><span class="s1">dot_str)</span>
            <span class="s1">fmt_index.insert(row_num + </span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.index:</span>
            <span class="s1">result = self.adj.adjoin(</span><span class="s5">3</span><span class="s2">, </span><span class="s1">*[fmt_index[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">fmt_values])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result = self.adj.adjoin(</span><span class="s5">3</span><span class="s2">, </span><span class="s1">fmt_values)</span>

        <span class="s2">if </span><span class="s1">self.header </span><span class="s2">and </span><span class="s1">have_header:</span>
            <span class="s1">result = fmt_index[</span><span class="s5">0</span><span class="s1">] + </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">+ result</span>

        <span class="s2">if </span><span class="s1">footer:</span>
            <span class="s1">result += </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">+ footer</span>

        <span class="s2">return </span><span class="s1">str(</span><span class="s3">&quot;&quot;</span><span class="s1">.join(result))</span>


<span class="s2">class </span><span class="s1">TextAdjustment:</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.encoding = get_option(</span><span class="s3">&quot;display.encoding&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">len(self</span><span class="s2">, </span><span class="s1">text: str) -&gt; int:</span>
        <span class="s2">return </span><span class="s1">len(text)</span>

    <span class="s2">def </span><span class="s1">justify(self</span><span class="s2">, </span><span class="s1">texts: Any</span><span class="s2">, </span><span class="s1">max_len: int</span><span class="s2">, </span><span class="s1">mode: str = </span><span class="s3">&quot;right&quot;</span><span class="s1">) -&gt; list[str]:</span>
        <span class="s2">return </span><span class="s1">justify(texts</span><span class="s2">, </span><span class="s1">max_len</span><span class="s2">, </span><span class="s1">mode=mode)</span>

    <span class="s2">def </span><span class="s1">adjoin(self</span><span class="s2">, </span><span class="s1">space: int</span><span class="s2">, </span><span class="s1">*lists</span><span class="s2">, </span><span class="s1">**kwargs) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">adjoin(space</span><span class="s2">, </span><span class="s1">*lists</span><span class="s2">, </span><span class="s1">strlen=self.len</span><span class="s2">, </span><span class="s1">justfunc=self.justify</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">EastAsianTextAdjustment(TextAdjustment):</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__()</span>
        <span class="s2">if </span><span class="s1">get_option(</span><span class="s3">&quot;display.unicode.ambiguous_as_wide&quot;</span><span class="s1">):</span>
            <span class="s1">self.ambiguous_width = </span><span class="s5">2</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.ambiguous_width = </span><span class="s5">1</span>

        <span class="s4"># Definition of East Asian Width</span>
        <span class="s4"># https://unicode.org/reports/tr11/</span>
        <span class="s4"># Ambiguous width can be changed by option</span>
        <span class="s1">self._EAW_MAP = {</span><span class="s3">&quot;Na&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;N&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;W&quot;</span><span class="s1">: </span><span class="s5">2</span><span class="s2">, </span><span class="s3">&quot;F&quot;</span><span class="s1">: </span><span class="s5">2</span><span class="s2">, </span><span class="s3">&quot;H&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">len(self</span><span class="s2">, </span><span class="s1">text: str) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot; 
        Calculate display width considering unicode East Asian Width 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(text</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">len(text)</span>

        <span class="s2">return </span><span class="s1">sum(</span>
            <span class="s1">self._EAW_MAP.get(east_asian_width(c)</span><span class="s2">, </span><span class="s1">self.ambiguous_width) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">text</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">justify(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">texts: Iterable[str]</span><span class="s2">, </span><span class="s1">max_len: int</span><span class="s2">, </span><span class="s1">mode: str = </span><span class="s3">&quot;right&quot;</span>
    <span class="s1">) -&gt; list[str]:</span>
        <span class="s4"># re-calculate padding space per str considering East Asian Width</span>
        <span class="s2">def </span><span class="s1">_get_pad(t):</span>
            <span class="s2">return </span><span class="s1">max_len - self.len(t) + len(t)</span>

        <span class="s2">if </span><span class="s1">mode == </span><span class="s3">&quot;left&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[x.ljust(_get_pad(x)) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">texts]</span>
        <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">&quot;center&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[x.center(_get_pad(x)) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">texts]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[x.rjust(_get_pad(x)) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">texts]</span>


<span class="s2">def </span><span class="s1">get_adjustment() -&gt; TextAdjustment:</span>
    <span class="s1">use_east_asian_width = get_option(</span><span class="s3">&quot;display.unicode.east_asian_width&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">use_east_asian_width:</span>
        <span class="s2">return </span><span class="s1">EastAsianTextAdjustment()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">TextAdjustment()</span>


<span class="s2">def </span><span class="s1">get_dataframe_repr_params() -&gt; dict[str</span><span class="s2">, </span><span class="s1">Any]:</span>
    <span class="s0">&quot;&quot;&quot;Get the parameters used to repr(dataFrame) calls using DataFrame.to_string. 
 
    Supplying these parameters to DataFrame.to_string is equivalent to calling 
    ``repr(DataFrame)``. This is useful if you want to adjust the repr output. 
 
    .. versionadded:: 1.4.0 
 
    Example 
    ------- 
    &gt;&gt;&gt; import pandas as pd 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; df = pd.DataFrame([[1, 2], [3, 4]]) 
    &gt;&gt;&gt; repr_params = pd.io.formats.format.get_dataframe_repr_params() 
    &gt;&gt;&gt; repr(df) == df.to_string(**repr_params) 
    True 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">pandas.io.formats </span><span class="s2">import </span><span class="s1">console</span>

    <span class="s2">if </span><span class="s1">get_option(</span><span class="s3">&quot;display.expand_frame_repr&quot;</span><span class="s1">):</span>
        <span class="s1">line_width</span><span class="s2">, </span><span class="s1">_ = console.get_console_size()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">line_width = </span><span class="s2">None</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s3">&quot;max_rows&quot;</span><span class="s1">: get_option(</span><span class="s3">&quot;display.max_rows&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;min_rows&quot;</span><span class="s1">: get_option(</span><span class="s3">&quot;display.min_rows&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;max_cols&quot;</span><span class="s1">: get_option(</span><span class="s3">&quot;display.max_columns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;max_colwidth&quot;</span><span class="s1">: get_option(</span><span class="s3">&quot;display.max_colwidth&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;show_dimensions&quot;</span><span class="s1">: get_option(</span><span class="s3">&quot;display.show_dimensions&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;line_width&quot;</span><span class="s1">: line_width</span><span class="s2">,</span>
    <span class="s1">}</span>


<span class="s2">def </span><span class="s1">get_series_repr_params() -&gt; dict[str</span><span class="s2">, </span><span class="s1">Any]:</span>
    <span class="s0">&quot;&quot;&quot;Get the parameters used to repr(Series) calls using Series.to_string. 
 
    Supplying these parameters to Series.to_string is equivalent to calling 
    ``repr(series)``. This is useful if you want to adjust the series repr output. 
 
    .. versionadded:: 1.4.0 
 
    Example 
    ------- 
    &gt;&gt;&gt; import pandas as pd 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; ser = pd.Series([1, 2, 3, 4]) 
    &gt;&gt;&gt; repr_params = pd.io.formats.format.get_series_repr_params() 
    &gt;&gt;&gt; repr(ser) == ser.to_string(**repr_params) 
    True 
    &quot;&quot;&quot;</span>
    <span class="s1">width</span><span class="s2">, </span><span class="s1">height = get_terminal_size()</span>
    <span class="s1">max_rows = (</span>
        <span class="s1">height</span>
        <span class="s2">if </span><span class="s1">get_option(</span><span class="s3">&quot;display.max_rows&quot;</span><span class="s1">) == </span><span class="s5">0</span>
        <span class="s2">else </span><span class="s1">get_option(</span><span class="s3">&quot;display.max_rows&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">min_rows = (</span>
        <span class="s1">height</span>
        <span class="s2">if </span><span class="s1">get_option(</span><span class="s3">&quot;display.max_rows&quot;</span><span class="s1">) == </span><span class="s5">0</span>
        <span class="s2">else </span><span class="s1">get_option(</span><span class="s3">&quot;display.min_rows&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">{</span>
        <span class="s3">&quot;name&quot;</span><span class="s1">: </span><span class="s2">True,</span>
        <span class="s3">&quot;dtype&quot;</span><span class="s1">: </span><span class="s2">True,</span>
        <span class="s3">&quot;min_rows&quot;</span><span class="s1">: min_rows</span><span class="s2">,</span>
        <span class="s3">&quot;max_rows&quot;</span><span class="s1">: max_rows</span><span class="s2">,</span>
        <span class="s3">&quot;length&quot;</span><span class="s1">: get_option(</span><span class="s3">&quot;display.show_dimensions&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">}</span>


<span class="s2">class </span><span class="s1">DataFrameFormatter:</span>
    <span class="s0">&quot;&quot;&quot;Class for processing dataframe formatting options and data.&quot;&quot;&quot;</span>

    <span class="s1">__doc__ = __doc__ </span><span class="s2">if </span><span class="s1">__doc__ </span><span class="s2">else </span><span class="s3">&quot;&quot;</span>
    <span class="s1">__doc__ += common_docstring + return_docstring</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">frame: DataFrame</span><span class="s2">,</span>
        <span class="s1">columns: Sequence[str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">col_space: ColspaceArgType | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">header: bool | Sequence[str] = </span><span class="s2">True,</span>
        <span class="s1">index: bool = </span><span class="s2">True,</span>
        <span class="s1">na_rep: str = </span><span class="s3">&quot;NaN&quot;</span><span class="s2">,</span>
        <span class="s1">formatters: FormattersType | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">justify: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">float_format: FloatFormatType | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">sparsify: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">index_names: bool = </span><span class="s2">True,</span>
        <span class="s1">max_rows: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">min_rows: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">max_cols: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">show_dimensions: bool | str = </span><span class="s2">False,</span>
        <span class="s1">decimal: str = </span><span class="s3">&quot;.&quot;</span><span class="s2">,</span>
        <span class="s1">bold_rows: bool = </span><span class="s2">False,</span>
        <span class="s1">escape: bool = </span><span class="s2">True,</span>
    <span class="s1">):</span>
        <span class="s1">self.frame = frame</span>
        <span class="s1">self.columns = self._initialize_columns(columns)</span>
        <span class="s1">self.col_space = self._initialize_colspace(col_space)</span>
        <span class="s1">self.header = header</span>
        <span class="s1">self.index = index</span>
        <span class="s1">self.na_rep = na_rep</span>
        <span class="s1">self.formatters = self._initialize_formatters(formatters)</span>
        <span class="s1">self.justify = self._initialize_justify(justify)</span>
        <span class="s1">self.float_format = float_format</span>
        <span class="s1">self.sparsify = self._initialize_sparsify(sparsify)</span>
        <span class="s1">self.show_index_names = index_names</span>
        <span class="s1">self.decimal = decimal</span>
        <span class="s1">self.bold_rows = bold_rows</span>
        <span class="s1">self.escape = escape</span>
        <span class="s1">self.max_rows = max_rows</span>
        <span class="s1">self.min_rows = min_rows</span>
        <span class="s1">self.max_cols = max_cols</span>
        <span class="s1">self.show_dimensions = show_dimensions</span>

        <span class="s1">self.max_cols_fitted = self._calc_max_cols_fitted()</span>
        <span class="s1">self.max_rows_fitted = self._calc_max_rows_fitted()</span>

        <span class="s1">self.tr_frame = self.frame</span>
        <span class="s1">self.truncate()</span>
        <span class="s1">self.adj = get_adjustment()</span>

    <span class="s2">def </span><span class="s1">get_strcols(self) -&gt; list[list[str]]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Render a DataFrame to a list of columns (as lists of strings). 
        &quot;&quot;&quot;</span>
        <span class="s1">strcols = self._get_strcols_without_index()</span>

        <span class="s2">if </span><span class="s1">self.index:</span>
            <span class="s1">str_index = self._get_formatted_index(self.tr_frame)</span>
            <span class="s1">strcols.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">str_index)</span>

        <span class="s2">return </span><span class="s1">strcols</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">should_show_dimensions(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self.show_dimensions </span><span class="s2">is True or </span><span class="s1">(</span>
            <span class="s1">self.show_dimensions == </span><span class="s3">&quot;truncate&quot; </span><span class="s2">and </span><span class="s1">self.is_truncated</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_truncated(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">bool(self.is_truncated_horizontally </span><span class="s2">or </span><span class="s1">self.is_truncated_vertically)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_truncated_horizontally(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">bool(self.max_cols_fitted </span><span class="s2">and </span><span class="s1">(len(self.columns) &gt; self.max_cols_fitted))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_truncated_vertically(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">bool(self.max_rows_fitted </span><span class="s2">and </span><span class="s1">(len(self.frame) &gt; self.max_rows_fitted))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">dimensions_info(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">\n\n</span><span class="s3">[</span><span class="s2">{</span><span class="s1">len(self.frame)</span><span class="s2">} </span><span class="s3">rows x </span><span class="s2">{</span><span class="s1">len(self.frame.columns)</span><span class="s2">} </span><span class="s3">columns]&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">has_index_names(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">_has_names(self.frame.index)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">has_column_names(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">_has_names(self.frame.columns)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">show_row_idx_names(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">all((self.has_index_names</span><span class="s2">, </span><span class="s1">self.index</span><span class="s2">, </span><span class="s1">self.show_index_names))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">show_col_idx_names(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">all((self.has_column_names</span><span class="s2">, </span><span class="s1">self.show_index_names</span><span class="s2">, </span><span class="s1">self.header))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">max_rows_displayed(self) -&gt; int:</span>
        <span class="s2">return </span><span class="s1">min(self.max_rows </span><span class="s2">or </span><span class="s1">len(self.frame)</span><span class="s2">, </span><span class="s1">len(self.frame))</span>

    <span class="s2">def </span><span class="s1">_initialize_sparsify(self</span><span class="s2">, </span><span class="s1">sparsify: bool | </span><span class="s2">None</span><span class="s1">) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">sparsify </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">get_option(</span><span class="s3">&quot;display.multi_sparse&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">sparsify</span>

    <span class="s2">def </span><span class="s1">_initialize_formatters(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">formatters: FormattersType | </span><span class="s2">None</span>
    <span class="s1">) -&gt; FormattersType:</span>
        <span class="s2">if </span><span class="s1">formatters </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">{}</span>
        <span class="s2">elif </span><span class="s1">len(self.frame.columns) == len(formatters) </span><span class="s2">or </span><span class="s1">isinstance(formatters</span><span class="s2">, </span><span class="s1">dict):</span>
            <span class="s2">return </span><span class="s1">formatters</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;Formatters length(</span><span class="s2">{</span><span class="s1">len(formatters)</span><span class="s2">}</span><span class="s3">) should match &quot;</span>
                <span class="s3">f&quot;DataFrame number of columns(</span><span class="s2">{</span><span class="s1">len(self.frame.columns)</span><span class="s2">}</span><span class="s3">)&quot;</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_initialize_justify(self</span><span class="s2">, </span><span class="s1">justify: str | </span><span class="s2">None</span><span class="s1">) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">justify </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">get_option(</span><span class="s3">&quot;display.colheader_justify&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">justify</span>

    <span class="s2">def </span><span class="s1">_initialize_columns(self</span><span class="s2">, </span><span class="s1">columns: Sequence[str] | </span><span class="s2">None</span><span class="s1">) -&gt; Index:</span>
        <span class="s2">if </span><span class="s1">columns </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">cols = ensure_index(columns)</span>
            <span class="s1">self.frame = self.frame[cols]</span>
            <span class="s2">return </span><span class="s1">cols</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.frame.columns</span>

    <span class="s2">def </span><span class="s1">_initialize_colspace(self</span><span class="s2">, </span><span class="s1">col_space: ColspaceArgType | </span><span class="s2">None</span><span class="s1">) -&gt; ColspaceType:</span>
        <span class="s1">result: ColspaceType</span>

        <span class="s2">if </span><span class="s1">col_space </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">result = {}</span>
        <span class="s2">elif </span><span class="s1">isinstance(col_space</span><span class="s2">, </span><span class="s1">(int</span><span class="s2">, </span><span class="s1">str)):</span>
            <span class="s1">result = {</span><span class="s3">&quot;&quot;</span><span class="s1">: col_space}</span>
            <span class="s1">result.update({column: col_space </span><span class="s2">for </span><span class="s1">column </span><span class="s2">in </span><span class="s1">self.frame.columns})</span>
        <span class="s2">elif </span><span class="s1">isinstance(col_space</span><span class="s2">, </span><span class="s1">Mapping):</span>
            <span class="s2">for </span><span class="s1">column </span><span class="s2">in </span><span class="s1">col_space.keys():</span>
                <span class="s2">if </span><span class="s1">column </span><span class="s2">not in </span><span class="s1">self.frame.columns </span><span class="s2">and </span><span class="s1">column != </span><span class="s3">&quot;&quot;</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">f&quot;Col_space is defined for an unknown column: </span><span class="s2">{</span><span class="s1">column</span><span class="s2">}</span><span class="s3">&quot;</span>
                    <span class="s1">)</span>
            <span class="s1">result = col_space</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">len(self.frame.columns) != len(col_space):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">f&quot;Col_space length(</span><span class="s2">{</span><span class="s1">len(col_space)</span><span class="s2">}</span><span class="s3">) should match &quot;</span>
                    <span class="s3">f&quot;DataFrame number of columns(</span><span class="s2">{</span><span class="s1">len(self.frame.columns)</span><span class="s2">}</span><span class="s3">)&quot;</span>
                <span class="s1">)</span>
            <span class="s1">result = dict(zip(self.frame.columns</span><span class="s2">, </span><span class="s1">col_space))</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_calc_max_cols_fitted(self) -&gt; int | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Number of columns fitting the screen.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._is_in_terminal():</span>
            <span class="s2">return </span><span class="s1">self.max_cols</span>

        <span class="s1">width</span><span class="s2">, </span><span class="s1">_ = get_terminal_size()</span>
        <span class="s2">if </span><span class="s1">self._is_screen_narrow(width):</span>
            <span class="s2">return </span><span class="s1">width</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.max_cols</span>

    <span class="s2">def </span><span class="s1">_calc_max_rows_fitted(self) -&gt; int | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Number of rows with data fitting the screen.&quot;&quot;&quot;</span>
        <span class="s1">max_rows: int | </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self._is_in_terminal():</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">height = get_terminal_size()</span>
            <span class="s2">if </span><span class="s1">self.max_rows == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4"># rows available to fill with actual data</span>
                <span class="s2">return </span><span class="s1">height - self._get_number_of_auxillary_rows()</span>

            <span class="s2">if </span><span class="s1">self._is_screen_short(height):</span>
                <span class="s1">max_rows = height</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">max_rows = self.max_rows</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">max_rows = self.max_rows</span>

        <span class="s2">return </span><span class="s1">self._adjust_max_rows(max_rows)</span>

    <span class="s2">def </span><span class="s1">_adjust_max_rows(self</span><span class="s2">, </span><span class="s1">max_rows: int | </span><span class="s2">None</span><span class="s1">) -&gt; int | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Adjust max_rows using display logic. 
 
        See description here: 
        https://pandas.pydata.org/docs/dev/user_guide/options.html#frequently-used-options 
 
        GH #37359 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">max_rows:</span>
            <span class="s2">if </span><span class="s1">(len(self.frame) &gt; max_rows) </span><span class="s2">and </span><span class="s1">self.min_rows:</span>
                <span class="s4"># if truncated, set max_rows showed to min_rows</span>
                <span class="s1">max_rows = min(self.min_rows</span><span class="s2">, </span><span class="s1">max_rows)</span>
        <span class="s2">return </span><span class="s1">max_rows</span>

    <span class="s2">def </span><span class="s1">_is_in_terminal(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Check if the output is to be shown in terminal.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">bool(self.max_cols == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">self.max_rows == </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_is_screen_narrow(self</span><span class="s2">, </span><span class="s1">max_width) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">bool(self.max_cols == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">len(self.frame.columns) &gt; max_width)</span>

    <span class="s2">def </span><span class="s1">_is_screen_short(self</span><span class="s2">, </span><span class="s1">max_height) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">bool(self.max_rows == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">len(self.frame) &gt; max_height)</span>

    <span class="s2">def </span><span class="s1">_get_number_of_auxillary_rows(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;Get number of rows occupied by prompt, dots and dimension info.&quot;&quot;&quot;</span>
        <span class="s1">dot_row = </span><span class="s5">1</span>
        <span class="s1">prompt_row = </span><span class="s5">1</span>
        <span class="s1">num_rows = dot_row + prompt_row</span>

        <span class="s2">if </span><span class="s1">self.show_dimensions:</span>
            <span class="s1">num_rows += len(self.dimensions_info.splitlines())</span>

        <span class="s2">if </span><span class="s1">self.header:</span>
            <span class="s1">num_rows += </span><span class="s5">1</span>

        <span class="s2">return </span><span class="s1">num_rows</span>

    <span class="s2">def </span><span class="s1">truncate(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Check whether the frame should be truncated. If so, slice the frame up. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.is_truncated_horizontally:</span>
            <span class="s1">self._truncate_horizontally()</span>

        <span class="s2">if </span><span class="s1">self.is_truncated_vertically:</span>
            <span class="s1">self._truncate_vertically()</span>

    <span class="s2">def </span><span class="s1">_truncate_horizontally(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Remove columns, which are not to be displayed and adjust formatters. 
 
        Attributes affected: 
            - tr_frame 
            - formatters 
            - tr_col_num 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self.max_cols_fitted </span><span class="s2">is not None</span>
        <span class="s1">col_num = self.max_cols_fitted // </span><span class="s5">2</span>
        <span class="s2">if </span><span class="s1">col_num &gt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">left = self.tr_frame.iloc[:</span><span class="s2">, </span><span class="s1">:col_num]</span>
            <span class="s1">right = self.tr_frame.iloc[:</span><span class="s2">, </span><span class="s1">-col_num:]</span>
            <span class="s1">self.tr_frame = concat((left</span><span class="s2">, </span><span class="s1">right)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>

            <span class="s4"># truncate formatter</span>
            <span class="s2">if </span><span class="s1">isinstance(self.formatters</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
                <span class="s1">self.formatters = [</span>
                    <span class="s1">*self.formatters[:col_num]</span><span class="s2">,</span>
                    <span class="s1">*self.formatters[-col_num:]</span><span class="s2">,</span>
                <span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">col_num = cast(int</span><span class="s2">, </span><span class="s1">self.max_cols)</span>
            <span class="s1">self.tr_frame = self.tr_frame.iloc[:</span><span class="s2">, </span><span class="s1">:col_num]</span>
        <span class="s1">self.tr_col_num = col_num</span>

    <span class="s2">def </span><span class="s1">_truncate_vertically(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Remove rows, which are not to be displayed. 
 
        Attributes affected: 
            - tr_frame 
            - tr_row_num 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self.max_rows_fitted </span><span class="s2">is not None</span>
        <span class="s1">row_num = self.max_rows_fitted // </span><span class="s5">2</span>
        <span class="s2">if </span><span class="s1">row_num &gt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">head = self.tr_frame.iloc[:row_num</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s1">tail = self.tr_frame.iloc[-row_num:</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s1">self.tr_frame = concat((head</span><span class="s2">, </span><span class="s1">tail))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">row_num = cast(int</span><span class="s2">, </span><span class="s1">self.max_rows)</span>
            <span class="s1">self.tr_frame = self.tr_frame.iloc[:row_num</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">self.tr_row_num = row_num</span>

    <span class="s2">def </span><span class="s1">_get_strcols_without_index(self) -&gt; list[list[str]]:</span>
        <span class="s1">strcols: list[list[str]] = []</span>

        <span class="s2">if not </span><span class="s1">is_list_like(self.header) </span><span class="s2">and not </span><span class="s1">self.header:</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">enumerate(self.tr_frame):</span>
                <span class="s1">fmt_values = self.format_col(i)</span>
                <span class="s1">fmt_values = _make_fixed_width(</span>
                    <span class="s1">strings=fmt_values</span><span class="s2">,</span>
                    <span class="s1">justify=self.justify</span><span class="s2">,</span>
                    <span class="s1">minimum=int(self.col_space.get(c</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">adj=self.adj</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s1">strcols.append(fmt_values)</span>
            <span class="s2">return </span><span class="s1">strcols</span>

        <span class="s2">if </span><span class="s1">is_list_like(self.header):</span>
            <span class="s4"># cast here since can't be bool if is_list_like</span>
            <span class="s1">self.header = cast(List[str]</span><span class="s2">, </span><span class="s1">self.header)</span>
            <span class="s2">if </span><span class="s1">len(self.header) != len(self.columns):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">f&quot;Writing </span><span class="s2">{</span><span class="s1">len(self.columns)</span><span class="s2">} </span><span class="s3">cols &quot;</span>
                    <span class="s3">f&quot;but got </span><span class="s2">{</span><span class="s1">len(self.header)</span><span class="s2">} </span><span class="s3">aliases&quot;</span>
                <span class="s1">)</span>
            <span class="s1">str_columns = [[label] </span><span class="s2">for </span><span class="s1">label </span><span class="s2">in </span><span class="s1">self.header]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">str_columns = self._get_formatted_column_labels(self.tr_frame)</span>

        <span class="s2">if </span><span class="s1">self.show_row_idx_names:</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">str_columns:</span>
                <span class="s1">x.append(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">enumerate(self.tr_frame):</span>
            <span class="s1">cheader = str_columns[i]</span>
            <span class="s1">header_colwidth = max(</span>
                <span class="s1">int(self.col_space.get(c</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span><span class="s2">, </span><span class="s1">*(self.adj.len(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">cheader)</span>
            <span class="s1">)</span>
            <span class="s1">fmt_values = self.format_col(i)</span>
            <span class="s1">fmt_values = _make_fixed_width(</span>
                <span class="s1">fmt_values</span><span class="s2">, </span><span class="s1">self.justify</span><span class="s2">, </span><span class="s1">minimum=header_colwidth</span><span class="s2">, </span><span class="s1">adj=self.adj</span>
            <span class="s1">)</span>

            <span class="s1">max_len = max(max(self.adj.len(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">fmt_values)</span><span class="s2">, </span><span class="s1">header_colwidth)</span>
            <span class="s1">cheader = self.adj.justify(cheader</span><span class="s2">, </span><span class="s1">max_len</span><span class="s2">, </span><span class="s1">mode=self.justify)</span>
            <span class="s1">strcols.append(cheader + fmt_values)</span>

        <span class="s2">return </span><span class="s1">strcols</span>

    <span class="s2">def </span><span class="s1">format_col(self</span><span class="s2">, </span><span class="s1">i: int) -&gt; list[str]:</span>
        <span class="s1">frame = self.tr_frame</span>
        <span class="s1">formatter = self._get_formatter(i)</span>
        <span class="s2">return </span><span class="s1">format_array(</span>
            <span class="s1">frame.iloc[:</span><span class="s2">, </span><span class="s1">i]._values</span><span class="s2">,</span>
            <span class="s1">formatter</span><span class="s2">,</span>
            <span class="s1">float_format=self.float_format</span><span class="s2">,</span>
            <span class="s1">na_rep=self.na_rep</span><span class="s2">,</span>
            <span class="s1">space=self.col_space.get(frame.columns[i])</span><span class="s2">,</span>
            <span class="s1">decimal=self.decimal</span><span class="s2">,</span>
            <span class="s1">leading_space=self.index</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_get_formatter(self</span><span class="s2">, </span><span class="s1">i: str | int) -&gt; Callable | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(self.formatters</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
            <span class="s2">if </span><span class="s1">is_integer(i):</span>
                <span class="s1">i = cast(int</span><span class="s2">, </span><span class="s1">i)</span>
                <span class="s2">return </span><span class="s1">self.formatters[i]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">is_integer(i) </span><span class="s2">and </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">self.columns:</span>
                <span class="s1">i = self.columns[i]</span>
            <span class="s2">return </span><span class="s1">self.formatters.get(i</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_get_formatted_column_labels(self</span><span class="s2">, </span><span class="s1">frame: DataFrame) -&gt; list[list[str]]:</span>
        <span class="s2">from </span><span class="s1">pandas.core.indexes.multi </span><span class="s2">import </span><span class="s1">sparsify_labels</span>

        <span class="s1">columns = frame.columns</span>

        <span class="s2">if </span><span class="s1">isinstance(columns</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">fmt_columns = columns.format(sparsify=</span><span class="s2">False, </span><span class="s1">adjoin=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">fmt_columns = list(zip(*fmt_columns))</span>
            <span class="s1">dtypes = self.frame.dtypes._values</span>

            <span class="s4"># if we have a Float level, they don't use leading space at all</span>
            <span class="s1">restrict_formatting = any(level.is_floating </span><span class="s2">for </span><span class="s1">level </span><span class="s2">in </span><span class="s1">columns.levels)</span>
            <span class="s1">need_leadsp = dict(zip(fmt_columns</span><span class="s2">, </span><span class="s1">map(is_numeric_dtype</span><span class="s2">, </span><span class="s1">dtypes)))</span>

            <span class="s2">def </span><span class="s1">space_format(x</span><span class="s2">, </span><span class="s1">y):</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">y </span><span class="s2">not in </span><span class="s1">self.formatters</span>
                    <span class="s2">and </span><span class="s1">need_leadsp[x]</span>
                    <span class="s2">and not </span><span class="s1">restrict_formatting</span>
                <span class="s1">):</span>
                    <span class="s2">return </span><span class="s3">&quot; &quot; </span><span class="s1">+ y</span>
                <span class="s2">return </span><span class="s1">y</span>

            <span class="s1">str_columns = list(</span>
                <span class="s1">zip(*([space_format(x</span><span class="s2">, </span><span class="s1">y) </span><span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">x] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">fmt_columns))</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.sparsify </span><span class="s2">and </span><span class="s1">len(str_columns):</span>
                <span class="s1">str_columns = sparsify_labels(str_columns)</span>

            <span class="s1">str_columns = [list(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">zip(*str_columns)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fmt_columns = columns.format()</span>
            <span class="s1">dtypes = self.frame.dtypes</span>
            <span class="s1">need_leadsp = dict(zip(fmt_columns</span><span class="s2">, </span><span class="s1">map(is_numeric_dtype</span><span class="s2">, </span><span class="s1">dtypes)))</span>
            <span class="s1">str_columns = [</span>
                <span class="s1">[</span><span class="s3">&quot; &quot; </span><span class="s1">+ x </span><span class="s2">if not </span><span class="s1">self._get_formatter(i) </span><span class="s2">and </span><span class="s1">need_leadsp[x] </span><span class="s2">else </span><span class="s1">x]</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(fmt_columns)</span>
            <span class="s1">]</span>
        <span class="s4"># self.str_columns = str_columns</span>
        <span class="s2">return </span><span class="s1">str_columns</span>

    <span class="s2">def </span><span class="s1">_get_formatted_index(self</span><span class="s2">, </span><span class="s1">frame: DataFrame) -&gt; list[str]:</span>
        <span class="s4"># Note: this is only used by to_string() and to_latex(), not by</span>
        <span class="s4"># to_html(). so safe to cast col_space here.</span>
        <span class="s1">col_space = {k: cast(int</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.col_space.items()}</span>
        <span class="s1">index = frame.index</span>
        <span class="s1">columns = frame.columns</span>
        <span class="s1">fmt = self._get_formatter(</span><span class="s3">&quot;__index__&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(index</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">fmt_index = index.format(</span>
                <span class="s1">sparsify=self.sparsify</span><span class="s2">,</span>
                <span class="s1">adjoin=</span><span class="s2">False,</span>
                <span class="s1">names=self.show_row_idx_names</span><span class="s2">,</span>
                <span class="s1">formatter=fmt</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fmt_index = [index.format(name=self.show_row_idx_names</span><span class="s2">, </span><span class="s1">formatter=fmt)]</span>

        <span class="s1">fmt_index = [</span>
            <span class="s1">tuple(</span>
                <span class="s1">_make_fixed_width(</span>
                    <span class="s1">list(x)</span><span class="s2">, </span><span class="s1">justify=</span><span class="s3">&quot;left&quot;</span><span class="s2">, </span><span class="s1">minimum=col_space.get(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">adj=self.adj</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">fmt_index</span>
        <span class="s1">]</span>

        <span class="s1">adjoined = self.adj.adjoin(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">*fmt_index).split(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>

        <span class="s4"># empty space for columns</span>
        <span class="s2">if </span><span class="s1">self.show_col_idx_names:</span>
            <span class="s1">col_header = [str(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self._get_column_name_list()]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">col_header = [</span><span class="s3">&quot;&quot;</span><span class="s1">] * columns.nlevels</span>

        <span class="s2">if </span><span class="s1">self.header:</span>
            <span class="s2">return </span><span class="s1">col_header + adjoined</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">adjoined</span>

    <span class="s2">def </span><span class="s1">_get_column_name_list(self) -&gt; list[str]:</span>
        <span class="s1">names: list[str] = []</span>
        <span class="s1">columns = self.frame.columns</span>
        <span class="s2">if </span><span class="s1">isinstance(columns</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">names.extend(</span><span class="s3">&quot;&quot; </span><span class="s2">if </span><span class="s1">name </span><span class="s2">is None else </span><span class="s1">name </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">columns.names)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">names.append(</span><span class="s3">&quot;&quot; </span><span class="s2">if </span><span class="s1">columns.name </span><span class="s2">is None else </span><span class="s1">columns.name)</span>
        <span class="s2">return </span><span class="s1">names</span>


<span class="s2">class </span><span class="s1">DataFrameRenderer:</span>
    <span class="s0">&quot;&quot;&quot;Class for creating dataframe output in multiple formats. 
 
    Called in pandas.core.generic.NDFrame: 
        - to_csv 
        - to_latex 
 
    Called in pandas.core.frame.DataFrame: 
        - to_html 
        - to_string 
 
    Parameters 
    ---------- 
    fmt : DataFrameFormatter 
        Formatter with the formatting options. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fmt: DataFrameFormatter):</span>
        <span class="s1">self.fmt = fmt</span>

    <span class="s2">def </span><span class="s1">to_latex(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">buf: FilePath | WriteBuffer[str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">column_format: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">longtable: bool = </span><span class="s2">False,</span>
        <span class="s1">encoding: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">multicolumn: bool = </span><span class="s2">False,</span>
        <span class="s1">multicolumn_format: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">multirow: bool = </span><span class="s2">False,</span>
        <span class="s1">caption: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">label: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">position: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; str | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Render a DataFrame to a LaTeX tabular/longtable environment output. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.io.formats.latex </span><span class="s2">import </span><span class="s1">LatexFormatter</span>

        <span class="s1">latex_formatter = LatexFormatter(</span>
            <span class="s1">self.fmt</span><span class="s2">,</span>
            <span class="s1">longtable=longtable</span><span class="s2">,</span>
            <span class="s1">column_format=column_format</span><span class="s2">,</span>
            <span class="s1">multicolumn=multicolumn</span><span class="s2">,</span>
            <span class="s1">multicolumn_format=multicolumn_format</span><span class="s2">,</span>
            <span class="s1">multirow=multirow</span><span class="s2">,</span>
            <span class="s1">caption=caption</span><span class="s2">,</span>
            <span class="s1">label=label</span><span class="s2">,</span>
            <span class="s1">position=position</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">string = latex_formatter.to_string()</span>
        <span class="s2">return </span><span class="s1">save_to_buffer(string</span><span class="s2">, </span><span class="s1">buf=buf</span><span class="s2">, </span><span class="s1">encoding=encoding)</span>

    <span class="s2">def </span><span class="s1">to_html(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">buf: FilePath | WriteBuffer[str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">encoding: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">classes: str | list | tuple | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">notebook: bool = </span><span class="s2">False,</span>
        <span class="s1">border: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">table_id: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">render_links: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; str | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Render a DataFrame to a html table. 
 
        Parameters 
        ---------- 
        buf : str, path object, file-like object, or None, default None 
            String, path object (implementing ``os.PathLike[str]``), or file-like 
            object implementing a string ``write()`` function. If None, the result is 
            returned as a string. 
        encoding : str, default “utf-8” 
            Set character encoding. 
        classes : str or list-like 
            classes to include in the `class` attribute of the opening 
            ``&lt;table&gt;`` tag, in addition to the default &quot;dataframe&quot;. 
        notebook : {True, False}, optional, default False 
            Whether the generated HTML is for IPython Notebook. 
        border : int 
            A ``border=border`` attribute is included in the opening 
            ``&lt;table&gt;`` tag. Default ``pd.options.display.html.border``. 
        table_id : str, optional 
            A css id is included in the opening `&lt;table&gt;` tag if specified. 
        render_links : bool, default False 
            Convert URLs to HTML links. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.io.formats.html </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">HTMLFormatter</span><span class="s2">,</span>
            <span class="s1">NotebookFormatter</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">Klass = NotebookFormatter </span><span class="s2">if </span><span class="s1">notebook </span><span class="s2">else </span><span class="s1">HTMLFormatter</span>

        <span class="s1">html_formatter = Klass(</span>
            <span class="s1">self.fmt</span><span class="s2">,</span>
            <span class="s1">classes=classes</span><span class="s2">,</span>
            <span class="s1">border=border</span><span class="s2">,</span>
            <span class="s1">table_id=table_id</span><span class="s2">,</span>
            <span class="s1">render_links=render_links</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">string = html_formatter.to_string()</span>
        <span class="s2">return </span><span class="s1">save_to_buffer(string</span><span class="s2">, </span><span class="s1">buf=buf</span><span class="s2">, </span><span class="s1">encoding=encoding)</span>

    <span class="s2">def </span><span class="s1">to_string(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">buf: FilePath | WriteBuffer[str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">encoding: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">line_width: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; str | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Render a DataFrame to a console-friendly tabular output. 
 
        Parameters 
        ---------- 
        buf : str, path object, file-like object, or None, default None 
            String, path object (implementing ``os.PathLike[str]``), or file-like 
            object implementing a string ``write()`` function. If None, the result is 
            returned as a string. 
        encoding: str, default “utf-8” 
            Set character encoding. 
        line_width : int, optional 
            Width to wrap a line in characters. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.io.formats.string </span><span class="s2">import </span><span class="s1">StringFormatter</span>

        <span class="s1">string_formatter = StringFormatter(self.fmt</span><span class="s2">, </span><span class="s1">line_width=line_width)</span>
        <span class="s1">string = string_formatter.to_string()</span>
        <span class="s2">return </span><span class="s1">save_to_buffer(string</span><span class="s2">, </span><span class="s1">buf=buf</span><span class="s2">, </span><span class="s1">encoding=encoding)</span>

    <span class="s2">def </span><span class="s1">to_csv(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">path_or_buf: FilePath | WriteBuffer[bytes] | WriteBuffer[str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">encoding: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">sep: str = </span><span class="s3">&quot;,&quot;</span><span class="s2">,</span>
        <span class="s1">columns: Sequence[Hashable] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">index_label: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">mode: str = </span><span class="s3">&quot;w&quot;</span><span class="s2">,</span>
        <span class="s1">compression: CompressionOptions = </span><span class="s3">&quot;infer&quot;</span><span class="s2">,</span>
        <span class="s1">quoting: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">quotechar: str = </span><span class="s3">'&quot;'</span><span class="s2">,</span>
        <span class="s1">line_terminator: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">chunksize: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">date_format: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">doublequote: bool = </span><span class="s2">True,</span>
        <span class="s1">escapechar: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">errors: str = </span><span class="s3">&quot;strict&quot;</span><span class="s2">,</span>
        <span class="s1">storage_options: StorageOptions = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; str | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Render dataframe as comma-separated file. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.io.formats.csvs </span><span class="s2">import </span><span class="s1">CSVFormatter</span>

        <span class="s2">if </span><span class="s1">path_or_buf </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">created_buffer = </span><span class="s2">True</span>
            <span class="s1">path_or_buf = StringIO()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">created_buffer = </span><span class="s2">False</span>

        <span class="s1">csv_formatter = CSVFormatter(</span>
            <span class="s1">path_or_buf=path_or_buf</span><span class="s2">,</span>
            <span class="s1">line_terminator=line_terminator</span><span class="s2">,</span>
            <span class="s1">sep=sep</span><span class="s2">,</span>
            <span class="s1">encoding=encoding</span><span class="s2">,</span>
            <span class="s1">errors=errors</span><span class="s2">,</span>
            <span class="s1">compression=compression</span><span class="s2">,</span>
            <span class="s1">quoting=quoting</span><span class="s2">,</span>
            <span class="s1">cols=columns</span><span class="s2">,</span>
            <span class="s1">index_label=index_label</span><span class="s2">,</span>
            <span class="s1">mode=mode</span><span class="s2">,</span>
            <span class="s1">chunksize=chunksize</span><span class="s2">,</span>
            <span class="s1">quotechar=quotechar</span><span class="s2">,</span>
            <span class="s1">date_format=date_format</span><span class="s2">,</span>
            <span class="s1">doublequote=doublequote</span><span class="s2">,</span>
            <span class="s1">escapechar=escapechar</span><span class="s2">,</span>
            <span class="s1">storage_options=storage_options</span><span class="s2">,</span>
            <span class="s1">formatter=self.fmt</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">csv_formatter.save()</span>

        <span class="s2">if </span><span class="s1">created_buffer:</span>
            <span class="s2">assert </span><span class="s1">isinstance(path_or_buf</span><span class="s2">, </span><span class="s1">StringIO)</span>
            <span class="s1">content = path_or_buf.getvalue()</span>
            <span class="s1">path_or_buf.close()</span>
            <span class="s2">return </span><span class="s1">content</span>

        <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">save_to_buffer(</span>
    <span class="s1">string: str</span><span class="s2">,</span>
    <span class="s1">buf: FilePath | WriteBuffer[str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">encoding: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
<span class="s1">) -&gt; str | </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform serialization. Write to buf or return as string if buf is None. 
    &quot;&quot;&quot;</span>
    <span class="s2">with </span><span class="s1">get_buffer(buf</span><span class="s2">, </span><span class="s1">encoding=encoding) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s1">f.write(string)</span>
        <span class="s2">if </span><span class="s1">buf </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">f.getvalue()</span>
        <span class="s2">return None</span>


<span class="s1">@contextmanager</span>
<span class="s2">def </span><span class="s1">get_buffer(buf: FilePath | WriteBuffer[str] | </span><span class="s2">None, </span><span class="s1">encoding: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Context manager to open, yield and close buffer for filenames or Path-like 
    objects, otherwise yield buf unchanged. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">buf </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">buf = stringify_path(buf)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">buf = StringIO()</span>

    <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">encoding = </span><span class="s3">&quot;utf-8&quot;</span>
    <span class="s2">elif not </span><span class="s1">isinstance(buf</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;buf is not a file name and encoding is specified.&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">hasattr(buf</span><span class="s2">, </span><span class="s3">&quot;write&quot;</span><span class="s1">):</span>
        <span class="s2">yield </span><span class="s1">buf</span>
    <span class="s2">elif </span><span class="s1">isinstance(buf</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">check_parent_directory(str(buf))</span>
        <span class="s2">with </span><span class="s1">open(buf</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s2">, </span><span class="s1">encoding=encoding</span><span class="s2">, </span><span class="s1">newline=</span><span class="s3">&quot;&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s4"># GH#30034 open instead of codecs.open prevents a file leak</span>
            <span class="s4">#  if we have an invalid encoding argument.</span>
            <span class="s4"># newline=&quot;&quot; is needed to roundtrip correctly on</span>
            <span class="s4">#  windows test_to_latex_filename</span>
            <span class="s2">yield </span><span class="s1">f</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;buf is not a file name and it has no write method&quot;</span><span class="s1">)</span>


<span class="s4"># ----------------------------------------------------------------------</span>
<span class="s4"># Array formatters</span>


<span class="s2">def </span><span class="s1">format_array(</span>
    <span class="s1">values: Any</span><span class="s2">,</span>
    <span class="s1">formatter: Callable | </span><span class="s2">None,</span>
    <span class="s1">float_format: FloatFormatType | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">na_rep: str = </span><span class="s3">&quot;NaN&quot;</span><span class="s2">,</span>
    <span class="s1">digits: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">space: str | int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">justify: str = </span><span class="s3">&quot;right&quot;</span><span class="s2">,</span>
    <span class="s1">decimal: str = </span><span class="s3">&quot;.&quot;</span><span class="s2">,</span>
    <span class="s1">leading_space: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">True,</span>
    <span class="s1">quoting: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
<span class="s1">) -&gt; list[str]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Format an array for printing. 
 
    Parameters 
    ---------- 
    values 
    formatter 
    float_format 
    na_rep 
    digits 
    space 
    justify 
    decimal 
    leading_space : bool, optional, default True 
        Whether the array should be formatted with a leading space. 
        When an array as a column of a Series or DataFrame, we do want 
        the leading space to pad between columns. 
 
        When formatting an Index subclass 
        (e.g. IntervalIndex._format_native_types), we don't want the 
        leading space since it should be left-aligned. 
 
    Returns 
    ------- 
    List[str] 
    &quot;&quot;&quot;</span>
    <span class="s1">fmt_klass: type[GenericArrayFormatter]</span>
    <span class="s2">if </span><span class="s1">is_datetime64_dtype(values.dtype):</span>
        <span class="s1">fmt_klass = Datetime64Formatter</span>
    <span class="s2">elif </span><span class="s1">is_datetime64tz_dtype(values.dtype):</span>
        <span class="s1">fmt_klass = Datetime64TZFormatter</span>
    <span class="s2">elif </span><span class="s1">is_timedelta64_dtype(values.dtype):</span>
        <span class="s1">fmt_klass = Timedelta64Formatter</span>
    <span class="s2">elif </span><span class="s1">is_extension_array_dtype(values.dtype):</span>
        <span class="s1">fmt_klass = ExtensionArrayFormatter</span>
    <span class="s2">elif </span><span class="s1">is_float_dtype(values.dtype) </span><span class="s2">or </span><span class="s1">is_complex_dtype(values.dtype):</span>
        <span class="s1">fmt_klass = FloatArrayFormatter</span>
    <span class="s2">elif </span><span class="s1">is_integer_dtype(values.dtype):</span>
        <span class="s1">fmt_klass = IntArrayFormatter</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">fmt_klass = GenericArrayFormatter</span>

    <span class="s2">if </span><span class="s1">space </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">space = get_option(</span><span class="s3">&quot;display.column_space&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">float_format </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">float_format = get_option(</span><span class="s3">&quot;display.float_format&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">digits </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">digits = get_option(</span><span class="s3">&quot;display.precision&quot;</span><span class="s1">)</span>

    <span class="s1">fmt_obj = fmt_klass(</span>
        <span class="s1">values</span><span class="s2">,</span>
        <span class="s1">digits=digits</span><span class="s2">,</span>
        <span class="s1">na_rep=na_rep</span><span class="s2">,</span>
        <span class="s1">float_format=float_format</span><span class="s2">,</span>
        <span class="s1">formatter=formatter</span><span class="s2">,</span>
        <span class="s1">space=space</span><span class="s2">,</span>
        <span class="s1">justify=justify</span><span class="s2">,</span>
        <span class="s1">decimal=decimal</span><span class="s2">,</span>
        <span class="s1">leading_space=leading_space</span><span class="s2">,</span>
        <span class="s1">quoting=quoting</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">fmt_obj.get_result()</span>


<span class="s2">class </span><span class="s1">GenericArrayFormatter:</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">values: Any</span><span class="s2">,</span>
        <span class="s1">digits: int = </span><span class="s5">7</span><span class="s2">,</span>
        <span class="s1">formatter: Callable | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">na_rep: str = </span><span class="s3">&quot;NaN&quot;</span><span class="s2">,</span>
        <span class="s1">space: str | int = </span><span class="s5">12</span><span class="s2">,</span>
        <span class="s1">float_format: FloatFormatType | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">justify: str = </span><span class="s3">&quot;right&quot;</span><span class="s2">,</span>
        <span class="s1">decimal: str = </span><span class="s3">&quot;.&quot;</span><span class="s2">,</span>
        <span class="s1">quoting: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">fixed_width: bool = </span><span class="s2">True,</span>
        <span class="s1">leading_space: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">True,</span>
    <span class="s1">):</span>
        <span class="s1">self.values = values</span>
        <span class="s1">self.digits = digits</span>
        <span class="s1">self.na_rep = na_rep</span>
        <span class="s1">self.space = space</span>
        <span class="s1">self.formatter = formatter</span>
        <span class="s1">self.float_format = float_format</span>
        <span class="s1">self.justify = justify</span>
        <span class="s1">self.decimal = decimal</span>
        <span class="s1">self.quoting = quoting</span>
        <span class="s1">self.fixed_width = fixed_width</span>
        <span class="s1">self.leading_space = leading_space</span>

    <span class="s2">def </span><span class="s1">get_result(self) -&gt; list[str]:</span>
        <span class="s1">fmt_values = self._format_strings()</span>
        <span class="s2">return </span><span class="s1">_make_fixed_width(fmt_values</span><span class="s2">, </span><span class="s1">self.justify)</span>

    <span class="s2">def </span><span class="s1">_format_strings(self) -&gt; list[str]:</span>
        <span class="s2">if </span><span class="s1">self.float_format </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">float_format = get_option(</span><span class="s3">&quot;display.float_format&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">float_format </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">precision = get_option(</span><span class="s3">&quot;display.precision&quot;</span><span class="s1">)</span>
                <span class="s1">float_format = </span><span class="s2">lambda </span><span class="s1">x: _trim_zeros_single_float(</span>
                    <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">x</span><span class="s2">: </span><span class="s3">.</span><span class="s2">{</span><span class="s1">precision</span><span class="s2">:</span><span class="s3">d</span><span class="s2">}</span><span class="s3">f</span><span class="s2">}</span><span class="s3">&quot;</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">float_format = self.float_format</span>

        <span class="s2">if </span><span class="s1">self.formatter </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">formatter = self.formatter</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">quote_strings = self.quoting </span><span class="s2">is not None and </span><span class="s1">self.quoting != QUOTE_NONE</span>
            <span class="s1">formatter = partial(</span>
                <span class="s1">pprint_thing</span><span class="s2">,</span>
                <span class="s1">escape_chars=(</span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\r</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">quote_strings=quote_strings</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s2">def </span><span class="s1">_format(x):</span>
            <span class="s2">if </span><span class="s1">self.na_rep </span><span class="s2">is not None and </span><span class="s1">is_scalar(x) </span><span class="s2">and </span><span class="s1">isna(x):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s4"># try block for np.isnat specifically</span>
                    <span class="s4"># determine na_rep if x is None or NaT-like</span>
                    <span class="s2">if </span><span class="s1">x </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s3">&quot;None&quot;</span>
                    <span class="s2">elif </span><span class="s1">x </span><span class="s2">is </span><span class="s1">NA:</span>
                        <span class="s2">return </span><span class="s1">str(NA)</span>
                    <span class="s2">elif </span><span class="s1">x </span><span class="s2">is </span><span class="s1">NaT </span><span class="s2">or </span><span class="s1">np.isnat(x):</span>
                        <span class="s2">return </span><span class="s3">&quot;NaT&quot;</span>
                <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
                    <span class="s4"># np.isnat only handles datetime or timedelta objects</span>
                    <span class="s2">pass</span>
                <span class="s2">return </span><span class="s1">self.na_rep</span>
            <span class="s2">elif </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">PandasObject):</span>
                <span class="s2">return </span><span class="s1">str(x)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># object dtype</span>
                <span class="s2">return </span><span class="s1">str(formatter(x))</span>

        <span class="s1">vals = extract_array(self.values</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(vals</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s3">&quot;ExtensionArray formatting should use ExtensionArrayFormatter&quot;</span>
            <span class="s1">)</span>
        <span class="s1">inferred = lib.map_infer(vals</span><span class="s2">, </span><span class="s1">is_float)</span>
        <span class="s1">is_float_type = (</span>
            <span class="s1">inferred</span>
            <span class="s4"># vals may have 2 or more dimensions</span>
            <span class="s1">&amp; np.all(notna(vals)</span><span class="s2">, </span><span class="s1">axis=tuple(range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">len(vals.shape))))</span>
        <span class="s1">)</span>
        <span class="s1">leading_space = self.leading_space</span>
        <span class="s2">if </span><span class="s1">leading_space </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">leading_space = is_float_type.any()</span>

        <span class="s1">fmt_values = []</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate(vals):</span>
            <span class="s2">if not </span><span class="s1">is_float_type[i] </span><span class="s2">and </span><span class="s1">leading_space:</span>
                <span class="s1">fmt_values.append(</span><span class="s3">f&quot; </span><span class="s2">{</span><span class="s1">_format(v)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">is_float_type[i]:</span>
                <span class="s1">fmt_values.append(float_format(v))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">leading_space </span><span class="s2">is False</span><span class="s1">:</span>
                    <span class="s4"># False specifically, so that the default is</span>
                    <span class="s4"># to include a space if we get here.</span>
                    <span class="s1">tpl = </span><span class="s3">&quot;{v}&quot;</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">tpl = </span><span class="s3">&quot; {v}&quot;</span>
                <span class="s1">fmt_values.append(tpl.format(v=_format(v)))</span>

        <span class="s2">return </span><span class="s1">fmt_values</span>


<span class="s2">class </span><span class="s1">FloatArrayFormatter(GenericArrayFormatter):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s4"># float_format is expected to be a string</span>
        <span class="s4"># formatter should be used to pass a function</span>
        <span class="s2">if </span><span class="s1">self.float_format </span><span class="s2">is not None and </span><span class="s1">self.formatter </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># GH21625, GH22270</span>
            <span class="s1">self.fixed_width = </span><span class="s2">False</span>
            <span class="s2">if </span><span class="s1">callable(self.float_format):</span>
                <span class="s1">self.formatter = self.float_format</span>
                <span class="s1">self.float_format = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_value_formatter(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">float_format: FloatFormatType | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">threshold: float | int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; Callable:</span>
        <span class="s0">&quot;&quot;&quot;Returns a function to be applied on each value to format it&quot;&quot;&quot;</span>
        <span class="s4"># the float_format parameter supersedes self.float_format</span>
        <span class="s2">if </span><span class="s1">float_format </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">float_format = self.float_format</span>

        <span class="s4"># we are going to compose different functions, to first convert to</span>
        <span class="s4"># a string, then replace the decimal symbol, and finally chop according</span>
        <span class="s4"># to the threshold</span>

        <span class="s4"># when there is no float_format, we use str instead of '%g'</span>
        <span class="s4"># because str(0.0) = '0.0' while '%g' % 0.0 = '0'</span>
        <span class="s2">if </span><span class="s1">float_format:</span>

            <span class="s2">def </span><span class="s1">base_formatter(v):</span>
                <span class="s2">assert </span><span class="s1">float_format </span><span class="s2">is not None  </span><span class="s4"># for mypy</span>
                <span class="s4"># error: &quot;str&quot; not callable</span>
                <span class="s4"># error: Unexpected keyword argument &quot;value&quot; for &quot;__call__&quot; of</span>
                <span class="s4"># &quot;EngFormatter&quot;</span>
                <span class="s2">return </span><span class="s1">(</span>
                    <span class="s1">float_format(value=v)  </span><span class="s4"># type: ignore[operator,call-arg]</span>
                    <span class="s2">if </span><span class="s1">notna(v)</span>
                    <span class="s2">else </span><span class="s1">self.na_rep</span>
                <span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>

            <span class="s2">def </span><span class="s1">base_formatter(v):</span>
                <span class="s2">return </span><span class="s1">str(v) </span><span class="s2">if </span><span class="s1">notna(v) </span><span class="s2">else </span><span class="s1">self.na_rep</span>

        <span class="s2">if </span><span class="s1">self.decimal != </span><span class="s3">&quot;.&quot;</span><span class="s1">:</span>

            <span class="s2">def </span><span class="s1">decimal_formatter(v):</span>
                <span class="s2">return </span><span class="s1">base_formatter(v).replace(</span><span class="s3">&quot;.&quot;</span><span class="s2">, </span><span class="s1">self.decimal</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">decimal_formatter = base_formatter</span>

        <span class="s2">if </span><span class="s1">threshold </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">decimal_formatter</span>

        <span class="s2">def </span><span class="s1">formatter(value):</span>
            <span class="s2">if </span><span class="s1">notna(value):</span>
                <span class="s2">if </span><span class="s1">abs(value) &gt; threshold:</span>
                    <span class="s2">return </span><span class="s1">decimal_formatter(value)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">decimal_formatter(</span><span class="s5">0.0</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.na_rep</span>

        <span class="s2">return </span><span class="s1">formatter</span>

    <span class="s2">def </span><span class="s1">get_result_as_array(self) -&gt; np.ndarray:</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the float values converted into strings using 
        the parameters given at initialisation, as a numpy array 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">format_with_na_rep(values: ArrayLike</span><span class="s2">, </span><span class="s1">formatter: Callable</span><span class="s2">, </span><span class="s1">na_rep: str):</span>
            <span class="s1">mask = isna(values)</span>
            <span class="s1">formatted = np.array(</span>
                <span class="s1">[</span>
                    <span class="s1">formatter(val) </span><span class="s2">if not </span><span class="s1">m </span><span class="s2">else </span><span class="s1">na_rep</span>
                    <span class="s2">for </span><span class="s1">val</span><span class="s2">, </span><span class="s1">m </span><span class="s2">in </span><span class="s1">zip(values.ravel()</span><span class="s2">, </span><span class="s1">mask.ravel())</span>
                <span class="s1">]</span>
            <span class="s1">).reshape(values.shape)</span>
            <span class="s2">return </span><span class="s1">formatted</span>

        <span class="s2">if </span><span class="s1">self.formatter </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">format_with_na_rep(self.values</span><span class="s2">, </span><span class="s1">self.formatter</span><span class="s2">, </span><span class="s1">self.na_rep)</span>

        <span class="s2">if </span><span class="s1">self.fixed_width:</span>
            <span class="s1">threshold = get_option(</span><span class="s3">&quot;display.chop_threshold&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">threshold = </span><span class="s2">None</span>

        <span class="s4"># if we have a fixed_width, we'll need to try different float_format</span>
        <span class="s2">def </span><span class="s1">format_values_with(float_format):</span>
            <span class="s1">formatter = self._value_formatter(float_format</span><span class="s2">, </span><span class="s1">threshold)</span>

            <span class="s4"># default formatter leaves a space to the left when formatting</span>
            <span class="s4"># floats, must be consistent for left-justifying NaNs (GH #25061)</span>
            <span class="s2">if </span><span class="s1">self.justify == </span><span class="s3">&quot;left&quot;</span><span class="s1">:</span>
                <span class="s1">na_rep = </span><span class="s3">&quot; &quot; </span><span class="s1">+ self.na_rep</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">na_rep = self.na_rep</span>

            <span class="s4"># separate the wheat from the chaff</span>
            <span class="s1">values = self.values</span>
            <span class="s1">is_complex = is_complex_dtype(values)</span>
            <span class="s1">values = format_with_na_rep(values</span><span class="s2">, </span><span class="s1">formatter</span><span class="s2">, </span><span class="s1">na_rep)</span>

            <span class="s2">if </span><span class="s1">self.fixed_width:</span>
                <span class="s2">if </span><span class="s1">is_complex:</span>
                    <span class="s1">result = _trim_zeros_complex(values</span><span class="s2">, </span><span class="s1">self.decimal)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">result = _trim_zeros_float(values</span><span class="s2">, </span><span class="s1">self.decimal)</span>
                <span class="s2">return </span><span class="s1">np.asarray(result</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>

            <span class="s2">return </span><span class="s1">values</span>

        <span class="s4"># There is a special default string when we are fixed-width</span>
        <span class="s4"># The default is otherwise to use str instead of a formatting string</span>
        <span class="s1">float_format: FloatFormatType | </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.float_format </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.fixed_width:</span>
                <span class="s2">if </span><span class="s1">self.leading_space </span><span class="s2">is True</span><span class="s1">:</span>
                    <span class="s1">fmt_str = </span><span class="s3">&quot;{value: .{digits:d}f}&quot;</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">fmt_str = </span><span class="s3">&quot;{value:.{digits:d}f}&quot;</span>
                <span class="s1">float_format = partial(fmt_str.format</span><span class="s2">, </span><span class="s1">digits=self.digits)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">float_format = self.float_format</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">float_format = </span><span class="s2">lambda </span><span class="s1">value: self.float_format % value</span>

        <span class="s1">formatted_values = format_values_with(float_format)</span>

        <span class="s2">if not </span><span class="s1">self.fixed_width:</span>
            <span class="s2">return </span><span class="s1">formatted_values</span>

        <span class="s4"># we need do convert to engineering format if some values are too small</span>
        <span class="s4"># and would appear as 0, or if some values are too big and take too</span>
        <span class="s4"># much space</span>

        <span class="s2">if </span><span class="s1">len(formatted_values) &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">maxlen = max(len(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">formatted_values)</span>
            <span class="s1">too_long = maxlen &gt; self.digits + </span><span class="s5">6</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">too_long = </span><span class="s2">False</span>

        <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">abs_vals = np.abs(self.values)</span>
            <span class="s4"># this is pretty arbitrary for now</span>
            <span class="s4"># large values: more that 8 characters including decimal symbol</span>
            <span class="s4"># and first digit, hence &gt; 1e6</span>
            <span class="s1">has_large_values = (abs_vals &gt; </span><span class="s5">1e6</span><span class="s1">).any()</span>
            <span class="s1">has_small_values = (</span>
                <span class="s1">(abs_vals &lt; </span><span class="s5">10 </span><span class="s1">** (-self.digits)) &amp; (abs_vals &gt; </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">).any()</span>

        <span class="s2">if </span><span class="s1">has_small_values </span><span class="s2">or </span><span class="s1">(too_long </span><span class="s2">and </span><span class="s1">has_large_values):</span>
            <span class="s2">if </span><span class="s1">self.leading_space </span><span class="s2">is True</span><span class="s1">:</span>
                <span class="s1">fmt_str = </span><span class="s3">&quot;{value: .{digits:d}e}&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">fmt_str = </span><span class="s3">&quot;{value:.{digits:d}e}&quot;</span>
            <span class="s1">float_format = partial(fmt_str.format</span><span class="s2">, </span><span class="s1">digits=self.digits)</span>
            <span class="s1">formatted_values = format_values_with(float_format)</span>

        <span class="s2">return </span><span class="s1">formatted_values</span>

    <span class="s2">def </span><span class="s1">_format_strings(self) -&gt; list[str]:</span>
        <span class="s2">return </span><span class="s1">list(self.get_result_as_array())</span>


<span class="s2">class </span><span class="s1">IntArrayFormatter(GenericArrayFormatter):</span>
    <span class="s2">def </span><span class="s1">_format_strings(self) -&gt; list[str]:</span>
        <span class="s2">if </span><span class="s1">self.leading_space </span><span class="s2">is False</span><span class="s1">:</span>
            <span class="s1">formatter_str = </span><span class="s2">lambda </span><span class="s1">x: </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">x</span><span class="s2">:</span><span class="s3">d</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">.format(x=x)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">formatter_str = </span><span class="s2">lambda </span><span class="s1">x: </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">x</span><span class="s2">: </span><span class="s3">d</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">.format(x=x)</span>
        <span class="s1">formatter = self.formatter </span><span class="s2">or </span><span class="s1">formatter_str</span>
        <span class="s1">fmt_values = [formatter(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.values]</span>
        <span class="s2">return </span><span class="s1">fmt_values</span>


<span class="s2">class </span><span class="s1">Datetime64Formatter(GenericArrayFormatter):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">values: np.ndarray | Series | DatetimeIndex | DatetimeArray</span><span class="s2">,</span>
        <span class="s1">nat_rep: str = </span><span class="s3">&quot;NaT&quot;</span><span class="s2">,</span>
        <span class="s1">date_format: </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(values</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.nat_rep = nat_rep</span>
        <span class="s1">self.date_format = date_format</span>

    <span class="s2">def </span><span class="s1">_format_strings(self) -&gt; list[str]:</span>
        <span class="s0">&quot;&quot;&quot;we by definition have DO NOT have a TZ&quot;&quot;&quot;</span>
        <span class="s1">values = self.values</span>

        <span class="s2">if not </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">DatetimeIndex):</span>
            <span class="s1">values = DatetimeIndex(values)</span>

        <span class="s2">if </span><span class="s1">self.formatter </span><span class="s2">is not None and </span><span class="s1">callable(self.formatter):</span>
            <span class="s2">return </span><span class="s1">[self.formatter(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">values]</span>

        <span class="s1">fmt_values = values._data._format_native_types(</span>
            <span class="s1">na_rep=self.nat_rep</span><span class="s2">, </span><span class="s1">date_format=self.date_format</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">fmt_values.tolist()</span>


<span class="s2">class </span><span class="s1">ExtensionArrayFormatter(GenericArrayFormatter):</span>
    <span class="s2">def </span><span class="s1">_format_strings(self) -&gt; list[str]:</span>
        <span class="s1">values = extract_array(self.values</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">formatter = self.formatter</span>
        <span class="s2">if </span><span class="s1">formatter </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># error: Item &quot;ndarray&quot; of &quot;Union[Any, Union[ExtensionArray, ndarray]]&quot; has</span>
            <span class="s4"># no attribute &quot;_formatter&quot;</span>
            <span class="s1">formatter = values._formatter(boxed=</span><span class="s2">True</span><span class="s1">)  </span><span class="s4"># type: ignore[union-attr]</span>

        <span class="s2">if </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">Categorical):</span>
            <span class="s4"># Categorical is special for now, so that we can preserve tzinfo</span>
            <span class="s1">array = values._internal_get_values()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">array = np.asarray(values)</span>

        <span class="s1">fmt_values = format_array(</span>
            <span class="s1">array</span><span class="s2">,</span>
            <span class="s1">formatter</span><span class="s2">,</span>
            <span class="s1">float_format=self.float_format</span><span class="s2">,</span>
            <span class="s1">na_rep=self.na_rep</span><span class="s2">,</span>
            <span class="s1">digits=self.digits</span><span class="s2">,</span>
            <span class="s1">space=self.space</span><span class="s2">,</span>
            <span class="s1">justify=self.justify</span><span class="s2">,</span>
            <span class="s1">decimal=self.decimal</span><span class="s2">,</span>
            <span class="s1">leading_space=self.leading_space</span><span class="s2">,</span>
            <span class="s1">quoting=self.quoting</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">fmt_values</span>


<span class="s2">def </span><span class="s1">format_percentiles(</span>
    <span class="s1">percentiles: (np.ndarray | list[int | float] | list[float] | list[str | float])</span><span class="s2">,</span>
<span class="s1">) -&gt; list[str]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Outputs rounded and formatted percentiles. 
 
    Parameters 
    ---------- 
    percentiles : list-like, containing floats from interval [0,1] 
 
    Returns 
    ------- 
    formatted : list of strings 
 
    Notes 
    ----- 
    Rounding precision is chosen so that: (1) if any two elements of 
    ``percentiles`` differ, they remain different after rounding 
    (2) no entry is *rounded* to 0% or 100%. 
    Any non-integer is always rounded to at least 1 decimal place. 
 
    Examples 
    -------- 
    Keeps all entries different after rounding: 
 
    &gt;&gt;&gt; format_percentiles([0.01999, 0.02001, 0.5, 0.666666, 0.9999]) 
    ['1.999%', '2.001%', '50%', '66.667%', '99.99%'] 
 
    No element is rounded to 0% or 100% (unless already equal to it). 
    Duplicates are allowed: 
 
    &gt;&gt;&gt; format_percentiles([0, 0.5, 0.02001, 0.5, 0.666666, 0.9999]) 
    ['0%', '50%', '2.0%', '50%', '66.67%', '99.99%'] 
    &quot;&quot;&quot;</span>
    <span class="s1">percentiles = np.asarray(percentiles)</span>

    <span class="s4"># It checks for np.NaN as well</span>
    <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">is_numeric_dtype(percentiles)</span>
            <span class="s2">or not </span><span class="s1">np.all(percentiles &gt;= </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">or not </span><span class="s1">np.all(percentiles &lt;= </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;percentiles should all be in the interval [0,1]&quot;</span><span class="s1">)</span>

    <span class="s1">percentiles = </span><span class="s5">100 </span><span class="s1">* percentiles</span>

    <span class="s1">int_idx = np.isclose(percentiles.astype(int)</span><span class="s2">, </span><span class="s1">percentiles)</span>

    <span class="s2">if </span><span class="s1">np.all(int_idx):</span>
        <span class="s1">out = percentiles.astype(int).astype(str)</span>
        <span class="s2">return </span><span class="s1">[i + </span><span class="s3">&quot;%&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">out]</span>

    <span class="s1">unique_pcts = np.unique(percentiles)</span>
    <span class="s1">to_begin = unique_pcts[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">unique_pcts[</span><span class="s5">0</span><span class="s1">] &gt; </span><span class="s5">0 </span><span class="s2">else None</span>
    <span class="s1">to_end = </span><span class="s5">100 </span><span class="s1">- unique_pcts[-</span><span class="s5">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">unique_pcts[-</span><span class="s5">1</span><span class="s1">] &lt; </span><span class="s5">100 </span><span class="s2">else None</span>

    <span class="s4"># Least precision that keeps percentiles unique after rounding</span>
    <span class="s1">prec = -np.floor(</span>
        <span class="s1">np.log10(np.min(np.ediff1d(unique_pcts</span><span class="s2">, </span><span class="s1">to_begin=to_begin</span><span class="s2">, </span><span class="s1">to_end=to_end)))</span>
    <span class="s1">).astype(int)</span>
    <span class="s1">prec = max(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">prec)</span>
    <span class="s1">out = np.empty_like(percentiles</span><span class="s2">, </span><span class="s1">dtype=object)</span>
    <span class="s1">out[int_idx] = percentiles[int_idx].astype(int).astype(str)</span>

    <span class="s1">out[~int_idx] = percentiles[~int_idx].round(prec).astype(str)</span>
    <span class="s2">return </span><span class="s1">[i + </span><span class="s3">&quot;%&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">out]</span>


<span class="s2">def </span><span class="s1">is_dates_only(values: np.ndarray | DatetimeArray | Index | DatetimeIndex) -&gt; bool:</span>
    <span class="s4"># return a boolean if we are only dates (and don't have a timezone)</span>
    <span class="s2">if not </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">Index):</span>
        <span class="s1">values = values.ravel()</span>

    <span class="s1">values = DatetimeIndex(values)</span>
    <span class="s2">if </span><span class="s1">values.tz </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">return False</span>

    <span class="s1">values_int = values.asi8</span>
    <span class="s1">consider_values = values_int != iNaT</span>
    <span class="s1">one_day_nanos = </span><span class="s5">86400 </span><span class="s1">* </span><span class="s5">10</span><span class="s1">**</span><span class="s5">9</span>
    <span class="s1">even_days = (</span>
        <span class="s1">np.logical_and(consider_values</span><span class="s2">, </span><span class="s1">values_int % int(one_day_nanos) != </span><span class="s5">0</span><span class="s1">).sum() == </span><span class="s5">0</span>
    <span class="s1">)</span>
    <span class="s2">if </span><span class="s1">even_days:</span>
        <span class="s2">return True</span>
    <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">_format_datetime64(x: NaTType | Timestamp</span><span class="s2">, </span><span class="s1">nat_rep: str = </span><span class="s3">&quot;NaT&quot;</span><span class="s1">) -&gt; str:</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s2">is </span><span class="s1">NaT:</span>
        <span class="s2">return </span><span class="s1">nat_rep</span>

    <span class="s2">return </span><span class="s1">str(x)</span>


<span class="s2">def </span><span class="s1">_format_datetime64_dateonly(</span>
    <span class="s1">x: NaTType | Timestamp</span><span class="s2">,</span>
    <span class="s1">nat_rep: str = </span><span class="s3">&quot;NaT&quot;</span><span class="s2">,</span>
    <span class="s1">date_format: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
<span class="s1">) -&gt; str:</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s2">is </span><span class="s1">NaT:</span>
        <span class="s2">return </span><span class="s1">nat_rep</span>

    <span class="s2">if </span><span class="s1">date_format:</span>
        <span class="s2">return </span><span class="s1">x.strftime(date_format)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s4"># error: Item &quot;NaTType&quot; of &quot;Union[NaTType, Any]&quot; has no attribute &quot;_date_repr&quot;</span>
        <span class="s4">#  The underlying problem here is that mypy doesn't understand that NaT</span>
        <span class="s4">#  is a singleton, so that the check above excludes it here.</span>
        <span class="s2">return </span><span class="s1">x._date_repr  </span><span class="s4"># type: ignore[union-attr]</span>


<span class="s2">def </span><span class="s1">get_format_datetime64(</span>
    <span class="s1">is_dates_only: bool</span><span class="s2">, </span><span class="s1">nat_rep: str = </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s1">date_format: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
<span class="s1">) -&gt; Callable:</span>

    <span class="s2">if </span><span class="s1">is_dates_only:</span>
        <span class="s2">return lambda </span><span class="s1">x: _format_datetime64_dateonly(</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">nat_rep=nat_rep</span><span class="s2">, </span><span class="s1">date_format=date_format</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return lambda </span><span class="s1">x: _format_datetime64(x</span><span class="s2">, </span><span class="s1">nat_rep=nat_rep)</span>


<span class="s2">def </span><span class="s1">get_format_datetime64_from_values(</span>
    <span class="s1">values: np.ndarray | DatetimeArray | DatetimeIndex</span><span class="s2">, </span><span class="s1">date_format: str | </span><span class="s2">None</span>
<span class="s1">) -&gt; str | </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;given values and a date_format, return a string format&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">values.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s4"># We don't actually care about the order of values, and DatetimeIndex</span>
        <span class="s4">#  only accepts 1D values</span>
        <span class="s1">values = values.ravel()</span>

    <span class="s1">ido = is_dates_only(values)</span>
    <span class="s2">if </span><span class="s1">ido:</span>
        <span class="s2">return </span><span class="s1">date_format </span><span class="s2">or </span><span class="s3">&quot;%Y-%m-%d&quot;</span>
    <span class="s2">return </span><span class="s1">date_format</span>


<span class="s2">class </span><span class="s1">Datetime64TZFormatter(Datetime64Formatter):</span>
    <span class="s2">def </span><span class="s1">_format_strings(self) -&gt; list[str]:</span>
        <span class="s0">&quot;&quot;&quot;we by definition have a TZ&quot;&quot;&quot;</span>
        <span class="s1">values = self.values.astype(object)</span>
        <span class="s1">ido = is_dates_only(values)</span>
        <span class="s1">formatter = self.formatter </span><span class="s2">or </span><span class="s1">get_format_datetime64(</span>
            <span class="s1">ido</span><span class="s2">, </span><span class="s1">date_format=self.date_format</span>
        <span class="s1">)</span>
        <span class="s1">fmt_values = [formatter(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">values]</span>

        <span class="s2">return </span><span class="s1">fmt_values</span>


<span class="s2">class </span><span class="s1">Timedelta64Formatter(GenericArrayFormatter):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">values: np.ndarray | TimedeltaIndex</span><span class="s2">,</span>
        <span class="s1">nat_rep: str = </span><span class="s3">&quot;NaT&quot;</span><span class="s2">,</span>
        <span class="s1">box: bool = </span><span class="s2">False,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(values</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.nat_rep = nat_rep</span>
        <span class="s1">self.box = box</span>

    <span class="s2">def </span><span class="s1">_format_strings(self) -&gt; list[str]:</span>
        <span class="s1">formatter = self.formatter </span><span class="s2">or </span><span class="s1">get_format_timedelta64(</span>
            <span class="s1">self.values</span><span class="s2">, </span><span class="s1">nat_rep=self.nat_rep</span><span class="s2">, </span><span class="s1">box=self.box</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">[formatter(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.values]</span>


<span class="s2">def </span><span class="s1">get_format_timedelta64(</span>
    <span class="s1">values: np.ndarray | TimedeltaIndex | TimedeltaArray</span><span class="s2">,</span>
    <span class="s1">nat_rep: str = </span><span class="s3">&quot;NaT&quot;</span><span class="s2">,</span>
    <span class="s1">box: bool = </span><span class="s2">False,</span>
<span class="s1">) -&gt; Callable:</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a formatter function for a range of timedeltas. 
    These will all have the same format argument 
 
    If box, then show the return in quotes 
    &quot;&quot;&quot;</span>
    <span class="s1">values_int = values.view(np.int64)</span>

    <span class="s1">consider_values = values_int != iNaT</span>

    <span class="s1">one_day_nanos = </span><span class="s5">86400 </span><span class="s1">* </span><span class="s5">10</span><span class="s1">**</span><span class="s5">9</span>
    <span class="s4"># error: Unsupported operand types for % (&quot;ExtensionArray&quot; and &quot;int&quot;)</span>
    <span class="s1">not_midnight = values_int % one_day_nanos != </span><span class="s5">0  </span><span class="s4"># type: ignore[operator]</span>
    <span class="s4"># error: Argument 1 to &quot;__call__&quot; of &quot;ufunc&quot; has incompatible type</span>
    <span class="s4"># &quot;Union[Any, ExtensionArray, ndarray]&quot;; expected</span>
    <span class="s4"># &quot;Union[Union[int, float, complex, str, bytes, generic],</span>
    <span class="s4"># Sequence[Union[int, float, complex, str, bytes, generic]],</span>
    <span class="s4"># Sequence[Sequence[Any]], _SupportsArray]&quot;</span>
    <span class="s1">both = np.logical_and(consider_values</span><span class="s2">, </span><span class="s1">not_midnight)  </span><span class="s4"># type: ignore[arg-type]</span>
    <span class="s1">even_days = both.sum() == </span><span class="s5">0</span>

    <span class="s2">if </span><span class="s1">even_days:</span>
        <span class="s1">format = </span><span class="s2">None</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">format = </span><span class="s3">&quot;long&quot;</span>

    <span class="s2">def </span><span class="s1">_formatter(x):</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s2">is None or </span><span class="s1">(is_scalar(x) </span><span class="s2">and </span><span class="s1">isna(x)):</span>
            <span class="s2">return </span><span class="s1">nat_rep</span>

        <span class="s2">if not </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">Timedelta):</span>
            <span class="s1">x = Timedelta(x)</span>
        <span class="s1">result = x._repr_base(format=format)</span>
        <span class="s2">if </span><span class="s1">box:</span>
            <span class="s1">result = </span><span class="s3">f&quot;'</span><span class="s2">{</span><span class="s1">result</span><span class="s2">}</span><span class="s3">'&quot;</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">return </span><span class="s1">_formatter</span>


<span class="s2">def </span><span class="s1">_make_fixed_width(</span>
    <span class="s1">strings: list[str]</span><span class="s2">,</span>
    <span class="s1">justify: str = </span><span class="s3">&quot;right&quot;</span><span class="s2">,</span>
    <span class="s1">minimum: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">adj: TextAdjustment | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
<span class="s1">) -&gt; list[str]:</span>

    <span class="s2">if </span><span class="s1">len(strings) == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">justify == </span><span class="s3">&quot;all&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">strings</span>

    <span class="s2">if </span><span class="s1">adj </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">adjustment = get_adjustment()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">adjustment = adj</span>

    <span class="s1">max_len = max(adjustment.len(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">strings)</span>

    <span class="s2">if </span><span class="s1">minimum </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">max_len = max(minimum</span><span class="s2">, </span><span class="s1">max_len)</span>

    <span class="s1">conf_max = get_option(</span><span class="s3">&quot;display.max_colwidth&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">conf_max </span><span class="s2">is not None and </span><span class="s1">max_len &gt; conf_max:</span>
        <span class="s1">max_len = conf_max</span>

    <span class="s2">def </span><span class="s1">just(x: str) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">conf_max </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(conf_max &gt; </span><span class="s5">3</span><span class="s1">) &amp; (adjustment.len(x) &gt; max_len):</span>
                <span class="s1">x = x[: max_len - </span><span class="s5">3</span><span class="s1">] + </span><span class="s3">&quot;...&quot;</span>
        <span class="s2">return </span><span class="s1">x</span>

    <span class="s1">strings = [just(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">strings]</span>
    <span class="s1">result = adjustment.justify(strings</span><span class="s2">, </span><span class="s1">max_len</span><span class="s2">, </span><span class="s1">mode=justify)</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_trim_zeros_complex(str_complexes: np.ndarray</span><span class="s2">, </span><span class="s1">decimal: str = </span><span class="s3">&quot;.&quot;</span><span class="s1">) -&gt; list[str]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Separates the real and imaginary parts from the complex number, and 
    executes the _trim_zeros_float method on each of those. 
    &quot;&quot;&quot;</span>
    <span class="s1">trimmed = [</span>
        <span class="s3">&quot;&quot;</span><span class="s1">.join(_trim_zeros_float(re.split(</span><span class="s3">r&quot;([j+-])&quot;</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">, </span><span class="s1">decimal))</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">str_complexes</span>
    <span class="s1">]</span>

    <span class="s4"># pad strings to the length of the longest trimmed string for alignment</span>
    <span class="s1">lengths = [len(s) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">trimmed]</span>
    <span class="s1">max_length = max(lengths)</span>
    <span class="s1">padded = [</span>
        <span class="s1">s[: -((k - </span><span class="s5">1</span><span class="s1">) // </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">)]  </span><span class="s4"># real part</span>
        <span class="s1">+ (max_length - k) // </span><span class="s5">2 </span><span class="s1">* </span><span class="s3">&quot;0&quot;</span>
        <span class="s1">+ s[-((k - </span><span class="s5">1</span><span class="s1">) // </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">) : -((k - </span><span class="s5">1</span><span class="s1">) // </span><span class="s5">2</span><span class="s1">)]  </span><span class="s4"># + / -</span>
        <span class="s1">+ s[-((k - </span><span class="s5">1</span><span class="s1">) // </span><span class="s5">2</span><span class="s1">) : -</span><span class="s5">1</span><span class="s1">]  </span><span class="s4"># imaginary part</span>
        <span class="s1">+ (max_length - k) // </span><span class="s5">2 </span><span class="s1">* </span><span class="s3">&quot;0&quot;</span>
        <span class="s1">+ s[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">zip(trimmed</span><span class="s2">, </span><span class="s1">lengths)</span>
    <span class="s1">]</span>
    <span class="s2">return </span><span class="s1">padded</span>


<span class="s2">def </span><span class="s1">_trim_zeros_single_float(str_float: str) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot; 
    Trims trailing zeros after a decimal point, 
    leaving just one if necessary. 
    &quot;&quot;&quot;</span>
    <span class="s1">str_float = str_float.rstrip(</span><span class="s3">&quot;0&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">str_float.endswith(</span><span class="s3">&quot;.&quot;</span><span class="s1">):</span>
        <span class="s1">str_float += </span><span class="s3">&quot;0&quot;</span>

    <span class="s2">return </span><span class="s1">str_float</span>


<span class="s2">def </span><span class="s1">_trim_zeros_float(</span>
    <span class="s1">str_floats: np.ndarray | list[str]</span><span class="s2">, </span><span class="s1">decimal: str = </span><span class="s3">&quot;.&quot;</span>
<span class="s1">) -&gt; list[str]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Trims the maximum number of trailing zeros equally from 
    all numbers containing decimals, leaving just one if 
    necessary. 
    &quot;&quot;&quot;</span>
    <span class="s1">trimmed = str_floats</span>
    <span class="s1">number_regex = re.compile(</span><span class="s3">rf&quot;^\s*[\+-]?[0-9]+\</span><span class="s2">{</span><span class="s1">decimal</span><span class="s2">}</span><span class="s3">[0-9]*$&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">is_number_with_decimal(x):</span>
        <span class="s2">return </span><span class="s1">re.match(number_regex</span><span class="s2">, </span><span class="s1">x) </span><span class="s2">is not None</span>

    <span class="s2">def </span><span class="s1">should_trim(values: np.ndarray | list[str]) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Determine if an array of strings should be trimmed. 
 
        Returns True if all numbers containing decimals (defined by the 
        above regular expression) within the array end in a zero, otherwise 
        returns False. 
        &quot;&quot;&quot;</span>
        <span class="s1">numbers = [x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">values </span><span class="s2">if </span><span class="s1">is_number_with_decimal(x)]</span>
        <span class="s2">return </span><span class="s1">len(numbers) &gt; </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">all(x.endswith(</span><span class="s3">&quot;0&quot;</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">numbers)</span>

    <span class="s2">while </span><span class="s1">should_trim(trimmed):</span>
        <span class="s1">trimmed = [x[:-</span><span class="s5">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">is_number_with_decimal(x) </span><span class="s2">else </span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">trimmed]</span>

    <span class="s4"># leave one 0 after the decimal points if need be.</span>
    <span class="s1">result = [</span>
        <span class="s1">x + </span><span class="s3">&quot;0&quot; </span><span class="s2">if </span><span class="s1">is_number_with_decimal(x) </span><span class="s2">and </span><span class="s1">x.endswith(decimal) </span><span class="s2">else </span><span class="s1">x</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">trimmed</span>
    <span class="s1">]</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_has_names(index: Index) -&gt; bool:</span>
    <span class="s2">if </span><span class="s1">isinstance(index</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
        <span class="s2">return </span><span class="s1">com.any_not_none(*index.names)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">index.name </span><span class="s2">is not None</span>


<span class="s2">class </span><span class="s1">EngFormatter:</span>
    <span class="s0">&quot;&quot;&quot; 
    Formats float values according to engineering format. 
 
    Based on matplotlib.ticker.EngFormatter 
    &quot;&quot;&quot;</span>

    <span class="s4"># The SI engineering prefixes</span>
    <span class="s1">ENG_PREFIXES = {</span>
        <span class="s1">-</span><span class="s5">24</span><span class="s1">: </span><span class="s3">&quot;y&quot;</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s5">21</span><span class="s1">: </span><span class="s3">&quot;z&quot;</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s5">18</span><span class="s1">: </span><span class="s3">&quot;a&quot;</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s5">15</span><span class="s1">: </span><span class="s3">&quot;f&quot;</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s5">12</span><span class="s1">: </span><span class="s3">&quot;p&quot;</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s5">9</span><span class="s1">: </span><span class="s3">&quot;n&quot;</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s5">6</span><span class="s1">: </span><span class="s3">&quot;u&quot;</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s5">3</span><span class="s1">: </span><span class="s3">&quot;m&quot;</span><span class="s2">,</span>
        <span class="s5">0</span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
        <span class="s5">3</span><span class="s1">: </span><span class="s3">&quot;k&quot;</span><span class="s2">,</span>
        <span class="s5">6</span><span class="s1">: </span><span class="s3">&quot;M&quot;</span><span class="s2">,</span>
        <span class="s5">9</span><span class="s1">: </span><span class="s3">&quot;G&quot;</span><span class="s2">,</span>
        <span class="s5">12</span><span class="s1">: </span><span class="s3">&quot;T&quot;</span><span class="s2">,</span>
        <span class="s5">15</span><span class="s1">: </span><span class="s3">&quot;P&quot;</span><span class="s2">,</span>
        <span class="s5">18</span><span class="s1">: </span><span class="s3">&quot;E&quot;</span><span class="s2">,</span>
        <span class="s5">21</span><span class="s1">: </span><span class="s3">&quot;Z&quot;</span><span class="s2">,</span>
        <span class="s5">24</span><span class="s1">: </span><span class="s3">&quot;Y&quot;</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">accuracy: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None, </span><span class="s1">use_eng_prefix: bool = </span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">self.accuracy = accuracy</span>
        <span class="s1">self.use_eng_prefix = use_eng_prefix</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">num: int | float) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Formats a number in engineering notation, appending a letter 
        representing the power of 1000 of the original number. Some examples: 
        &gt;&gt;&gt; format_eng = EngFormatter(accuracy=0, use_eng_prefix=True) 
        &gt;&gt;&gt; format_eng(0) 
        ' 0' 
        &gt;&gt;&gt; format_eng = EngFormatter(accuracy=1, use_eng_prefix=True) 
        &gt;&gt;&gt; format_eng(1_000_000) 
        ' 1.0M' 
        &gt;&gt;&gt; format_eng = EngFormatter(accuracy=2, use_eng_prefix=False) 
        &gt;&gt;&gt; format_eng(&quot;-1e-6&quot;) 
        '-1.00E-06' 
 
        @param num: the value to represent 
        @type num: either a numeric value or a string that can be converted to 
                   a numeric value (as per decimal.Decimal constructor) 
 
        @return: engineering formatted string 
        &quot;&quot;&quot;</span>
        <span class="s1">dnum = decimal.Decimal(str(num))</span>

        <span class="s2">if </span><span class="s1">decimal.Decimal.is_nan(dnum):</span>
            <span class="s2">return </span><span class="s3">&quot;NaN&quot;</span>

        <span class="s2">if </span><span class="s1">decimal.Decimal.is_infinite(dnum):</span>
            <span class="s2">return </span><span class="s3">&quot;inf&quot;</span>

        <span class="s1">sign = </span><span class="s5">1</span>

        <span class="s2">if </span><span class="s1">dnum &lt; </span><span class="s5">0</span><span class="s1">:  </span><span class="s4"># pragma: no cover</span>
            <span class="s1">sign = -</span><span class="s5">1</span>
            <span class="s1">dnum = -dnum</span>

        <span class="s2">if </span><span class="s1">dnum != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">pow10 = decimal.Decimal(int(math.floor(dnum.log10() / </span><span class="s5">3</span><span class="s1">) * </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pow10 = decimal.Decimal(</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">pow10 = pow10.min(max(self.ENG_PREFIXES.keys()))</span>
        <span class="s1">pow10 = pow10.max(min(self.ENG_PREFIXES.keys()))</span>
        <span class="s1">int_pow10 = int(pow10)</span>

        <span class="s2">if </span><span class="s1">self.use_eng_prefix:</span>
            <span class="s1">prefix = self.ENG_PREFIXES[int_pow10]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">int_pow10 &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">prefix = </span><span class="s3">f&quot;E-</span><span class="s2">{</span><span class="s1">-int_pow10</span><span class="s2">:</span><span class="s3">02d</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">prefix = </span><span class="s3">f&quot;E+</span><span class="s2">{</span><span class="s1">int_pow10</span><span class="s2">:</span><span class="s3">02d</span><span class="s2">}</span><span class="s3">&quot;</span>

        <span class="s1">mant = sign * dnum / (</span><span class="s5">10</span><span class="s1">**pow10)</span>

        <span class="s2">if </span><span class="s1">self.accuracy </span><span class="s2">is None</span><span class="s1">:  </span><span class="s4"># pragma: no cover</span>
            <span class="s1">format_str = </span><span class="s3">&quot;{mant: g}{prefix}&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">format_str = </span><span class="s3">f&quot;</span><span class="s2">{{</span><span class="s3">mant: .</span><span class="s2">{</span><span class="s1">self.accuracy</span><span class="s2">:</span><span class="s3">d</span><span class="s2">}</span><span class="s3">f</span><span class="s2">}}{{</span><span class="s3">prefix</span><span class="s2">}}</span><span class="s3">&quot;</span>

        <span class="s1">formatted = format_str.format(mant=mant</span><span class="s2">, </span><span class="s1">prefix=prefix)</span>

        <span class="s2">return </span><span class="s1">formatted</span>


<span class="s2">def </span><span class="s1">set_eng_float_format(accuracy: int = </span><span class="s5">3</span><span class="s2">, </span><span class="s1">use_eng_prefix: bool = </span><span class="s2">False</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Alter default behavior on how float is formatted in DataFrame. 
    Format float in engineering format. By accuracy, we mean the number of 
    decimal digits after the floating point. 
 
    See also EngFormatter. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_option(</span><span class="s3">&quot;display.float_format&quot;</span><span class="s2">, </span><span class="s1">EngFormatter(accuracy</span><span class="s2">, </span><span class="s1">use_eng_prefix))</span>
    <span class="s1">set_option(</span><span class="s3">&quot;display.column_space&quot;</span><span class="s2">, </span><span class="s1">max(</span><span class="s5">12</span><span class="s2">, </span><span class="s1">accuracy + </span><span class="s5">9</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">get_level_lengths(</span>
    <span class="s1">levels: Any</span><span class="s2">, </span><span class="s1">sentinel: bool | object | str = </span><span class="s3">&quot;&quot;</span>
<span class="s1">) -&gt; list[dict[int</span><span class="s2">, </span><span class="s1">int]]:</span>
    <span class="s0">&quot;&quot;&quot; 
    For each index in each level the function returns lengths of indexes. 
 
    Parameters 
    ---------- 
    levels : list of lists 
        List of values on for level. 
    sentinel : string, optional 
        Value which states that no new index starts on there. 
 
    Returns 
    ------- 
    Returns list of maps. For each level returns map of indexes (key is index 
    in row and value is length of index). 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">len(levels) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s1">control = [</span><span class="s2">True</span><span class="s1">] * len(levels[</span><span class="s5">0</span><span class="s1">])</span>

    <span class="s1">result = []</span>
    <span class="s2">for </span><span class="s1">level </span><span class="s2">in </span><span class="s1">levels:</span>
        <span class="s1">last_index = </span><span class="s5">0</span>

        <span class="s1">lengths = {}</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">key </span><span class="s2">in </span><span class="s1">enumerate(level):</span>
            <span class="s2">if </span><span class="s1">control[i] </span><span class="s2">and </span><span class="s1">key == sentinel:</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">control[i] = </span><span class="s2">False</span>
                <span class="s1">lengths[last_index] = i - last_index</span>
                <span class="s1">last_index = i</span>

        <span class="s1">lengths[last_index] = len(level) - last_index</span>

        <span class="s1">result.append(lengths)</span>

    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">buffer_put_lines(buf: WriteBuffer[str]</span><span class="s2">, </span><span class="s1">lines: list[str]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Appends lines to a buffer. 
 
    Parameters 
    ---------- 
    buf 
        The buffer to write to 
    lines 
        The lines to append. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">any(isinstance(x</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">lines):</span>
        <span class="s1">lines = [str(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">lines]</span>
    <span class="s1">buf.write(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(lines))</span>
</pre>
</body>
</html>